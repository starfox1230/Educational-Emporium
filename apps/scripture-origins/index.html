<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bible vs Book of Mormon Globe</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <style>
    :root {
      --bg: #0b1020;
      --accent: #ffd27f;
      --text: #f4f5f6;
      --book-gold: #f3c86b;
    }
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      margin: 0;
      background: radial-gradient(circle at top, #18243a 0%, #080a10 48%, #03040a 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    #app {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* Scene */
    #scene-container {
      position: absolute;
      inset: 0;
    }
    canvas { display: block; }

    /* Info bar */
    #info-bar {
      position: fixed;
      left: 10px;
      right: 10px;
      bottom: 140px; /* on mobile, above book bar */
      background: rgba(5, 6, 10, 0.65);
      border: 1px solid rgba(255,255,255,0.045);
      border-radius: 14px;
      backdrop-filter: blur(14px);
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px 14px;
      z-index: 20;
      pointer-events: auto;
      flex-wrap: wrap;
    }
    #info-title {
      font-weight: 600;
      font-size: .85rem;
    }
    #info-text {
      font-size: .78rem;
      opacity: .9;
      line-height: 1.2;
      flex: 1;
      min-width: 240px;
    }
    #focus-hint {
      font-size: .65rem;
      opacity: .45;
      white-space: nowrap;
    }

    /* Book bar (mobile-first) */
    #book-panel {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      min-height: 120px;
      background: radial-gradient(circle at top, rgba(8,10,16,0.15), rgba(8,10,16,0.95));
      backdrop-filter: blur(16px);
      border-top: 1px solid rgba(255,255,255,0.04);
      display: flex;
      gap: 12px;
      padding: 12px 14px 16px;
      overflow-x: auto;
      z-index: 30;
      align-items: stretch;
    }
    .panel-title {
      display: none; /* mobile: no label */
    }
    .book-card {
      flex: 0 0 170px;
      border-radius: 14px;
      padding: 14px 12px 12px;
      border: 1px solid rgba(243, 200, 107, 0.15);
      position: relative;
      overflow: hidden;
      cursor: pointer;
      transition: transform .15s ease;
      user-select: none;
      touch-action: manipulation;
    }
    .book-card:active {
      transform: scale(.985);
    }
    .book-card::after {
      content: "";
      position: absolute;
      inset: -30% -10%;
      background: radial-gradient(circle, rgba(255,255,255,0.15), transparent 55%);
      transform: rotate(14deg);
      pointer-events: none;
    }
    .book-title {
      font-family: "Georgia", "Times New Roman", serif;
      font-size: 1rem;
      line-height: 1.05;
      letter-spacing: .03em;
      text-transform: uppercase;
      margin-bottom: .35rem;
    }
    .book-sub {
      font-size: .7rem;
      opacity: .8;
    }
    .book-card.bible {
      background: radial-gradient(circle at 25% 10%, #09121c, #000000 70%, #000000 100%);
      color: var(--book-gold);
    }
    .book-card.bom {
      background: radial-gradient(circle at 10% 25%, #123b6e, #091d3a 60%, #030712 100%);
      color: var(--book-gold);
    }

    /* Larger screens */
    @media (min-width: 900px) {
      #book-panel {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        width: 260px;
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        border-top: none;
        border-left: 1px solid rgba(255,255,255,0.04);
        min-height: 100vh;
      }
      .panel-title {
        display: block;
        font-size: 0.75rem;
        letter-spacing: .04em;
        opacity: .8;
        text-transform: uppercase;
        margin-bottom: .35rem;
      }
      .book-card {
        flex: 0 0 auto;
      }
      #info-bar {
        bottom: 10px;
        left: 10px;
        right: 280px;
      }
    }
  </style>
</head>
<body>
<div id="app">
  <div id="scene-container"></div>

  <div id="info-bar">
    <div id="info-title">Bible</div>
    <div id="info-text">
      Events in and around Jerusalem, Israel, Egypt, Mesopotamia, and the Mediterranean world.
    </div>
    <div id="focus-hint">Drag to rotate. Pinch/scroll to zoom.</div>
  </div>

  <div id="book-panel">
    <div class="panel-title">Tap a volume</div>
    <div class="book-card bible" data-target="bible">
      <div class="book-title">
        <div>THE</div>
        <div>HOLY BIBLE</div>
      </div>
      <div class="book-sub">Near East, Mediterranean</div>
    </div>
    <div class="book-card bom" data-target="bom">
      <div class="book-title">
        <div>THE</div>
        <div>BOOK OF</div>
        <div>MORMON</div>
      </div>
      <div class="book-sub">Ancient Americas (~600 BC+)</div>
    </div>
  </div>
</div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.162.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.162.0/examples/js/controls/OrbitControls.js"></script>
<script>
(function() {
  const container = document.getElementById("scene-container");
  const infoTitle = document.getElementById("info-title");
  const infoText = document.getElementById("info-text");
  const bookPanel = document.getElementById("book-panel");

  // Scene
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x030509);

  // Camera
  const camera = new THREE.PerspectiveCamera(
    45,
    container.clientWidth / container.clientHeight,
    0.1,
    1000
  );
  camera.position.set(0, 1.6, 3.6);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  resizeRenderer();
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.appendChild(renderer.domElement);

  // Lights
  scene.add(new THREE.HemisphereLight(0xffffff, 0x080820, 1.1));
  const dl = new THREE.DirectionalLight(0xffffff, 0.9);
  dl.position.set(5, 2, 5);
  scene.add(dl);

  // Globe
  const RADIUS = 1;
  const globeGeo = new THREE.SphereGeometry(RADIUS, 64, 64);
  const globeMat = new THREE.MeshStandardMaterial({
    color: 0x0b4b78,
    roughness: 0.45,
    metalness: 0.12
  });
  const globe = new THREE.Mesh(globeGeo, globeMat);
  scene.add(globe);

  // lat/lon helper
  function latLonToVector3(lat, lon, radius) {
    const phi = THREE.MathUtils.degToRad(90 - lat);
    const theta = THREE.MathUtils.degToRad(lon + 180);
    const x = -(radius) * Math.sin(phi) * Math.cos(theta);
    const z = (radius) * Math.sin(phi) * Math.sin(theta);
    const y = (radius) * Math.cos(phi);
    return new THREE.Vector3(x, y, z);
  }

  // lines
  const linesGroup = new THREE.Group();
  globe.add(linesGroup);
  function createLat(latDeg) {
    const lat = THREE.MathUtils.degToRad(latDeg);
    const latRadius = Math.cos(lat) * RADIUS * 1.001;
    const y = Math.sin(lat) * RADIUS * 1.001;
    const latGeo = new THREE.TorusGeometry(latRadius, 0.0014, 6, 96);
    const latMat = new THREE.MeshBasicMaterial({ color: 0x2aa7ff, opacity: 0.2, transparent: true });
    const mesh = new THREE.Mesh(latGeo, latMat);
    mesh.rotation.x = Math.PI / 2;
    mesh.position.y = y;
    linesGroup.add(mesh);
  }
  function createLon(lonDeg) {
    const seg = 96;
    const pos = [];
    for (let i = 0; i <= seg; i++) {
      const theta = (i / seg) * Math.PI - Math.PI / 2;
      const r = RADIUS * 1.001;
      const x = r * Math.cos(theta) * Math.cos(THREE.MathUtils.degToRad(lonDeg));
      const y = r * Math.sin(theta);
      const z = r * Math.cos(theta) * Math.sin(THREE.MathUtils.degToRad(lonDeg));
      pos.push(x,y,z);
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
    const mat = new THREE.LineBasicMaterial({ color: 0x2aa7ff, opacity: 0.12, transparent: true });
    linesGroup.add(new THREE.Line(geo, mat));
  }
  for (let lat = -60; lat <= 60; lat += 30) createLat(lat);
  for (let lon = -150; lon <= 180; lon += 30) createLon(lon);

  // markers
  const markersGroup = new THREE.Group();
  scene.add(markersGroup);
  function createMarker(lat, lon, color, label) {
    const mGeo = new THREE.SphereGeometry(0.025, 12, 12);
    const mMat = new THREE.MeshBasicMaterial({ color });
    const m = new THREE.Mesh(mGeo, mMat);
    m.position.copy(latLonToVector3(lat, lon, RADIUS * 1.01));
    m.userData.label = label;
    markersGroup.add(m);
    return m;
  }
  const bibleMarker = createMarker(31.78, 35.23, 0xffeb99, "Jerusalem (Bible core)");
  const bomMarker   = createMarker(15, -90, 0xff8ba1, "Ancient Americas (Book of Mormon)");

  // controls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.enablePan = false;
  controls.minDistance = 1.5;
  controls.maxDistance = 5.5;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.6;

  // animate
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  function flyToLatLon(lat, lon, title, text) {
    const targetVec = latLonToVector3(lat, lon, RADIUS);
    const target = targetVec.clone().normalize();
    const targetPhi = Math.acos(target.y);
    const targetTheta = Math.atan2(target.x, target.z);

    const startRotY = globe.rotation.y;
    const startRotX = globe.rotation.x;
    const desiredRotY = targetTheta;
    const desiredRotX = targetPhi - Math.PI / 2;

    const start = performance.now();
    const duration = 580;
    function step(now) {
      const t = Math.min(1, (now - start) / duration);
      const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      globe.rotation.y = THREE.MathUtils.lerp(startRotY, desiredRotY, ease);
      globe.rotation.x = THREE.MathUtils.lerp(startRotX, desiredRotX, ease * 0.9);
      if (t < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);

    infoTitle.textContent = title;
    infoText.textContent = text;
  }

  // tap/click handler (mobile-safe)
  function handleBookTap(target) {
    if (target === "bible") {
      flyToLatLon(
        31.78, 35.23,
        "Bible",
        "Written over many centuries in the Near East. Old Testament in Israel and surrounding empires; New Testament in and around Judea, Galilee, and the Mediterranean."
      );
    } else if (target === "bom") {
      flyToLatLon(
        15, -90,
        "Book of Mormon",
        "A record of peoples in the ancient Americas, beginning with a family leaving Jerusalem around 600 BC and later compiled and translated in the 1800s."
      );
    }
  }

  // Support both click and touchstart
  function bookPanelListener(evt) {
    const card = evt.target.closest(".book-card");
    if (!card) return;
    evt.preventDefault();
    handleBookTap(card.dataset.target);
  }
  bookPanel.addEventListener("click", bookPanelListener, { passive: false });
  bookPanel.addEventListener("touchstart", bookPanelListener, { passive: false });

  // raycast tap on markers
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  renderer.domElement.addEventListener("pointerdown", (event) => {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(markersGroup.children);
    if (intersects.length > 0) {
      const obj = intersects[0].object;
      infoTitle.textContent = "Location";
      infoText.textContent = obj.userData.label || "Marker";
    }
  });

  // initial focus
  flyToLatLon(31.78, 35.23, "Bible",
    "Events in and around Jerusalem, Israel, Egypt, Mesopotamia, and the Mediterranean world.");

  // resize
  window.addEventListener("resize", resizeRenderer);
  function resizeRenderer() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
})();
</script>
</body>
</html>