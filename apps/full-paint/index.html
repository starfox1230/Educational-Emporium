<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Full-Res Painter</title>
  <style>
    body {
      margin: 0;
      background: #121212;
      color: #e0e0e0;
      font-family: sans-serif;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #app-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: hidden;
      /* transform-origin: top left; */ /* Set in JS if needed */
    }

    #canvas-container {
      margin: 0;
      width: 100%; 
      height: 100%;
      position: absolute; 
      top: 0;
      left: 0;
    }

    canvas#paint-canvas {
      display: block;
    }

    #brush-preview {
      position: fixed;
      border: 2px solid rgba(224, 224, 224, 0.7);
      border-radius: 50%;
      background-color: rgba(128, 128, 128, 0.3);
      pointer-events: none;
      display: none;
      z-index: 1000;
      box-sizing: border-box;
    }

    #controls-panel {
      position: absolute; 
      bottom: 0;
      left: 0;
      width: 100%;
      background: #1a1a1a;
      z-index: 100;
      transform: translateY(100%);
      transition: transform 0.3s ease-out;
      padding: 20px 10px 10px 10px;
      box-sizing: border-box;
      max-height: 60%; 
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      border-top: 1px solid #333;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
    }

    #controls-panel.open {
      transform: translateY(0);
    }

    #panel-toggle-btn {
      position: absolute; 
      left: 50%;
      bottom: 0px;
      transform: translateX(-50%);
      background: #6200ee;
      color: white;
      border: none;
      padding: 8px 20px;
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      cursor: pointer;
      z-index: 101;
      transition: bottom 0.3s ease-out, background-color 0.2s;
      font-size: 16px;
    }
    #panel-toggle-btn:hover {
      background: #7c4dff;
    }

    /* Styles for controls inside the panel (largely unchanged) */
    #controls-panel #controls { margin: 0 0 16px 0; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; width: 100%; }
    #controls-panel button { padding: 8px 12px; border: none; border-radius: 8px; background: #6200ee; color: white; cursor: pointer; transition: background-color 0.2s; }
    #controls-panel button:hover { background: #7c4dff; }
    #controls-panel button:disabled { background: #444; cursor: not-allowed; }
    #controls-panel #palette-container { display: flex; align-items: center; width: 100%; max-width: 500px; margin-bottom: 12px; }
    .eraser-btn-palette { width: 36px; height: 36px; border: 2px solid transparent; border-radius: 8px; cursor: pointer; transition: transform 0.1s, border-color 0.1s; background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 7px 7px; background-color: #fff; flex-shrink: 0; margin-right: 4px; }
    .eraser-btn-palette.selected { border-color: #e0e0e0; transform: scale(1.1); }
    #controls-panel #color-palette { display: flex; flex-direction: row; flex-wrap: nowrap; overflow-x: auto; padding: 6px 4px; background: #2c2c2c; border-radius: 10px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.5); flex-grow: 1; }
    #controls-panel .color-btn { width: 36px; height: 36px; border: 2px solid transparent; border-radius: 8px; cursor: pointer; transition: transform 0.1s; flex: 0 0 auto; margin-right: 4px; }
    #controls-panel .color-btn.selected { border-color: #e0e0e0; transform: scale(1.1); }
    #controls-panel .slider-group { width: 100%; max-width: 500px; margin-bottom: 12px; text-align: center; }
    #controls-panel .slider-group label { display: block; margin-bottom: 4px; font-size: 14px; }
    #controls-panel input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 10px; background: #444; outline: none; border-radius: 5px; margin-top: 4px; }
    #controls-panel input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #6200ee; border-radius: 50%; cursor: pointer; }
    #controls-panel input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #6200ee; border-radius: 50%; cursor: pointer; border: none; }
    #controls-panel #clear-toggle-container { width: 100%; max-width: 500px; margin-bottom: 10px; text-align: center; font-size: 15px; }

  </style>
</head>
<body>
  <div id="app-container">
    <div id="canvas-container">
      <canvas id="paint-canvas"></canvas>
    </div>
    <div id="brush-preview"></div>

    <button id="panel-toggle-btn">▲ Tools</button>
    <div id="controls-panel">
      <div id="controls">
        <button id="clear-canvas-btn">Clear Canvas</button>
        <button id="undo-btn">Undo</button>
        <button id="redo-btn">Redo</button>
        <button id="save-btn">Save PNG</button>
      </div>
      <div class="slider-group">
        <label for="brush-size-slider">Brush Size: <span id="brush-size-value">5</span>px</label>
        <input type="range" id="brush-size-slider" min="1" max="100" value="5">
      </div>
      <div id="palette-container">
        <div id="color-palette"></div>
      </div>
      <div class="slider-group">
        <label for="brightness-slider">Color Brightness</label>
        <input type="range" id="brightness-slider" min="-50" max="50" value="0">
      </div>
      <div id="clear-toggle-container">
        <label>
          <input type="checkbox" id="clear-toggle">
          Depict Transparent as Black
        </label>
      </div>
    </div>
  </div>

  <script>
    const ERASER = "eraser";
    let brightnessOffset = 0;
    let depictClearAsBlack = false;

    const TOTAL_RAINBOW_COLORS = 32;
    const baseRainbowHues = Array.from({ length: TOTAL_RAINBOW_COLORS }, (_, i) => i * (360 / TOTAL_RAINBOW_COLORS));

    const appContainer = document.getElementById('app-container');
    const displayCanvas = document.getElementById('paint-canvas');
    const displayCtx = displayCanvas.getContext('2d');
    const dataCanvas = document.createElement('canvas');
    const dataCtx = dataCanvas.getContext('2d', { willReadFrequently: true });
    const brushPreviewEl = document.getElementById('brush-preview');
    let brushPreviewTimeout;

    let selectedColor = 1;
    let currentBrushSize = 5;
    let isDrawing = false;
    let lastX, lastY;
    let isRotated = false; 
    let currentAppRotation = 0; // Store the current rotation degrees
    const dpr = window.devicePixelRatio || 1; // Define dpr globally for convenience

    let undoStack = [];
    let redoStack = [];
    const MAX_UNDO_STEPS = 20;

    document.addEventListener('contextmenu', e => e.preventDefault());

    function getPaletteColor(index) { /* ... same ... */ }
    function buildPaletteScrollable() { /* ... same ... */ }
    function getPaletteColor(index) {
      if (index === 0) return ERASER;
      if (index === 1) return "#000000";
      if (index === 2) return "#FFFFFF";
      if (index === 3) {
        let lightness = Math.min(100, Math.max(0, 50 + brightnessOffset));
        return `hsl(0, 0%, ${lightness}%)`;
      }
      let j = index - 4;
      let lightness = Math.min(100, Math.max(0, 50 + brightnessOffset));
      return `hsl(${baseRainbowHues[j % TOTAL_RAINBOW_COLORS]}, 100%, ${lightness}%)`;
    }
    function buildPaletteScrollable() {
      const palette = [];
      const totalPaletteColors = 3 + TOTAL_RAINBOW_COLORS;
      for (let i = 1; i <= totalPaletteColors; i++){
        palette.push(getPaletteColor(i));
      }
      return palette;
    }

    function redrawDisplayCanvas() {
      displayCtx.save(); 
      displayCtx.setTransform(1,0,0,1,0,0); // Reset transform for absolute clearing/drawing

      if (depictClearAsBlack) {
        displayCtx.fillStyle = '#000000';
        displayCtx.fillRect(0, 0, displayCanvas.width, displayCanvas.height); // Fill entire buffer
      } else {
        displayCtx.clearRect(0, 0, displayCanvas.width, displayCanvas.height); // Clear entire buffer
      }
      
      // Draw dataCanvas buffer directly to displayCanvas buffer, 1:1 pixel mapping
      // since displayCtx transform is currently identity.
      displayCtx.drawImage(dataCanvas, 0, 0); 
      
      displayCtx.restore(); // Restore original transform of displayCtx (which includes DPR scaling set in orientAndSizeUI)
    }

    function saveState() { /* ... same ... */ }
    function applyState(pureImageData) { /* ... same ... */ }
    function updateUndoRedoButtons() { /* ... same ... */ }
    saveState = function () {
      if (undoStack.length >= MAX_UNDO_STEPS) undoStack.shift();
      undoStack.push(dataCtx.getImageData(0, 0, dataCanvas.width, dataCanvas.height));
      redoStack = [];
      updateUndoRedoButtons();
    }
    applyState = function (pureImageData) {
      if (pureImageData) {
        if (dataCanvas.width !== pureImageData.width || dataCanvas.height !== pureImageData.height) {
            dataCanvas.width = pureImageData.width;
            dataCanvas.height = pureImageData.height;
            // Reapply DPR scaling to dataCtx if canvas dimensions changed
            dataCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        dataCtx.putImageData(pureImageData, 0, 0);
      } else {
        // Ensure dataCtx is scaled before clearing, if it's a fresh clear
        dataCtx.setTransform(dpr, 0, 0, dpr, 0, 0); // Ensure transform for operations
        dataCtx.clearRect(0, 0, dataCanvas.width / dpr, dataCanvas.height / dpr); // Clear logical area
      }
      redrawDisplayCanvas();
      updateUndoRedoButtons();
    }
    updateUndoRedoButtons = function () {
      document.getElementById('undo-btn').disabled = undoStack.length === 0;
      document.getElementById('redo-btn').disabled = redoStack.length === 0;
    }


    function getPointerPos(e) {
        const rect = displayCanvas.getBoundingClientRect();

        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        let xOnScreen = clientX - rect.left;
        let yOnScreen = clientY - rect.top;

        let logicalX, logicalY;

        if (isRotated) {
            // Transformation for 90deg clockwise rotation of appContainer where
            // original bottom-left of app becomes screen top-left.
            // screenX maps to canvas Y (inverted and offset)
            // screenY maps to canvas X
            // rect.width is on-screen width of displayCanvas (original logicalHeight, e.g., vw)
            // rect.height is on-screen height of displayCanvas (original logicalWidth, e.g., vh)
            logicalX = yOnScreen;
            logicalY = rect.width - xOnScreen; 
        } else { // Not rotated
            logicalX = xOnScreen;
            logicalY = yOnScreen;
        }
        
        // Return logical coordinates. dataCtx is already scaled by DPR,
        // so it expects logical coordinates for its drawing operations.
        return { x: logicalX, y: logicalY };
    }


    function startDrawing(e) { /* ... same, uses new getPointerPos ... */ }
    function draw(e) { /* ... same, uses new getPointerPos ... */ }
    function stopDrawing() { /* ... same ... */ }
    startDrawing = function (e) {
      if (controlsPanel.classList.contains('open')) return;
      saveState();
      isDrawing = true;
      const pos = getPointerPos(e); // Gets logical coordinates
      [lastX, lastY] = [pos.x, pos.y];
      const actualColor = getPaletteColor(selectedColor);
      if (actualColor === ERASER) {
        dataCtx.globalCompositeOperation = 'destination-out';
      } else {
        dataCtx.globalCompositeOperation = 'source-over';
        dataCtx.strokeStyle = actualColor;
        dataCtx.fillStyle = actualColor;
      }
      // currentBrushSize is logical. dataCtx is scaled by DPR, so line/arc will be scaled.
      dataCtx.lineWidth = currentBrushSize; 
      dataCtx.lineCap = 'round';
      dataCtx.lineJoin = 'round';
      
      // Draw a single point for click/tap
      dataCtx.beginPath();
      dataCtx.arc(lastX, lastY, currentBrushSize / 2, 0, Math.PI * 2);
      dataCtx.fill();

      // Prepare for dragging
      dataCtx.beginPath(); // Start new path for the line segment
      dataCtx.moveTo(lastX, lastY);
      redrawDisplayCanvas();
    }
    draw = function (e) {
      if (!isDrawing || controlsPanel.classList.contains('open')) return;
      const pos = getPointerPos(e); // Gets logical coordinates
      dataCtx.lineTo(pos.x, pos.y);
      dataCtx.stroke();
      
      // For smoother lines when moving fast, begin new path segment from current point
      dataCtx.beginPath(); 
      dataCtx.moveTo(pos.x, pos.y);
      
      [lastX, lastY] = [pos.x, pos.y];
      redrawDisplayCanvas();
    }
    stopDrawing = function () {
      if (!isDrawing) return;
      // dataCtx.beginPath(); // No longer needed here as draw() manages it
      isDrawing = false;
      updateUndoRedoButtons(); // Consider if state should be saved on mouseup (done in startDrawing)
    }

    displayCanvas.addEventListener('mousedown', startDrawing);
    displayCanvas.addEventListener('mousemove', draw);
    document.addEventListener('mouseup', stopDrawing);
    displayCanvas.addEventListener('mouseleave', stopDrawing); // Could also call stopDrawing
    displayCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); }, { passive: false });
    displayCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); }, { passive: false });
    document.addEventListener('touchend', stopDrawing);


    document.getElementById('clear-canvas-btn').addEventListener('click', () => { /* ... same ... */ });
    document.getElementById('undo-btn').addEventListener('click', () => { /* ... same ... */ });
    document.getElementById('redo-btn').addEventListener('click', () => { /* ... same ... */ });
    document.getElementById('save-btn').addEventListener('click', () => { /* ... same ... */ });
    document.getElementById('clear-canvas-btn').onclick = () => {
      saveState();
      // Clear logical area, dataCtx scale will handle buffer
      dataCtx.clearRect(0, 0, dataCanvas.width / dpr, dataCanvas.height / dpr); 
      redrawDisplayCanvas();
    };
    document.getElementById('undo-btn').onclick = () => {
      if (undoStack.length > 0) {
        redoStack.push(dataCtx.getImageData(0, 0, dataCanvas.width, dataCanvas.height));
        const prevState = undoStack.pop();
        applyState(prevState);
      }
    };
    document.getElementById('redo-btn').onclick = () => {
      if (redoStack.length > 0) {
        undoStack.push(dataCtx.getImageData(0, 0, dataCanvas.width, dataCanvas.height));
        const nextState = redoStack.pop();
        applyState(nextState);
      }
    };
    document.getElementById('save-btn').onclick = () => {
      const randomStr = Math.random().toString(36).substring(2, 7);
      const link = document.createElement('a');
      link.download = `paint-art-${randomStr}.png`;
      link.href = dataCanvas.toDataURL('image/png');
      link.click();
    };

    function selectColor(index) { /* ... same ... */ }
    function initPalette() { /* ... same ... */ }
    selectColor = function (index) {
      selectedColor = index;
      document.querySelectorAll('.eraser-btn-palette, .color-btn').forEach(btn => btn.classList.remove('selected'));
      const selectedButton = document.querySelector(`#controls-panel [data-color="${index}"]`);
      if (selectedButton) selectedButton.classList.add('selected');
    }
    initPalette = function () {
      const paletteContainer = document.getElementById('palette-container');
      const scrollablePalette = document.getElementById('color-palette');
      const scrollPos = scrollablePalette.scrollLeft;
      const existingEraser = paletteContainer.querySelector('.eraser-btn-palette');
      if (existingEraser) existingEraser.remove();
      scrollablePalette.innerHTML = '';
      const eraserBtn = document.createElement('button');
      eraserBtn.className = 'eraser-btn-palette';
      eraserBtn.dataset.color = "0";
      eraserBtn.addEventListener('click', () => selectColor(0));
      if (selectedColor == 0) eraserBtn.classList.add('selected');
      paletteContainer.prepend(eraserBtn);
      const scrollableColors = buildPaletteScrollable();
      scrollableColors.forEach((color, idx) => {
        const btn = document.createElement('button');
        btn.className = 'color-btn';
        const actualIndex = idx + 1;
        btn.dataset.color = actualIndex;
        btn.style.backgroundColor = color;
        btn.addEventListener('click', () => selectColor(actualIndex));
        if (selectedColor == actualIndex) btn.classList.add('selected');
        scrollablePalette.appendChild(btn);
      });
      scrollablePalette.scrollLeft = scrollPos;
    }
    
    const brushSizeSlider = document.getElementById('brush-size-slider');
    brushSizeSlider.addEventListener('input', (e) => {
      currentBrushSize = parseInt(e.target.value); // This is logical brush size
      document.getElementById('brush-size-value').textContent = currentBrushSize;

      // Brush preview is in CSS pixels, so it should match logical currentBrushSize
      const cssBrushDiameter = currentBrushSize; 

      brushPreviewEl.style.width = cssBrushDiameter + 'px';
      brushPreviewEl.style.height = cssBrushDiameter + 'px';
      
      // Center on screen (viewport)
      brushPreviewEl.style.left = (window.innerWidth / 2 - cssBrushDiameter / 2) + 'px';
      brushPreviewEl.style.top = (window.innerHeight / 2 - cssBrushDiameter / 2) + 'px';
      brushPreviewEl.style.display = 'block';

      clearTimeout(brushPreviewTimeout);
      brushPreviewTimeout = setTimeout(() => {
        brushPreviewEl.style.display = 'none';
      }, 1500);
    });
    brushSizeSlider.addEventListener('change', () => { /* ... same ... */ });
    brushSizeSlider.onchange = () => {
        clearTimeout(brushPreviewTimeout);
        brushPreviewEl.style.display = 'none';
    };


    document.getElementById('brightness-slider').addEventListener('input', (e) => { /* ... same ... */ });
    document.getElementById('brightness-slider').oninput = (e) => {
      brightnessOffset = parseInt(e.target.value);
      initPalette();
    };

    document.getElementById('clear-toggle').addEventListener('change', (e) => {
      depictClearAsBlack = e.target.checked;
      redrawDisplayCanvas();
    });
    
    const controlsPanel = document.getElementById('controls-panel');
    const panelToggleBtn = document.getElementById('panel-toggle-btn');

    panelToggleBtn.addEventListener('click', () => {
      controlsPanel.classList.toggle('open');
      // Allow CSS transition to compute height before moving button
      requestAnimationFrame(() => {
        const panelHeight = controlsPanel.offsetHeight;
        if (controlsPanel.classList.contains('open')) {
            panelToggleBtn.textContent = '▼ Close';
            panelToggleBtn.style.bottom = panelHeight + 'px';
        } else {
            panelToggleBtn.textContent = '▲ Tools';
            panelToggleBtn.style.bottom = '0px';
            clearTimeout(brushPreviewTimeout);
            brushPreviewEl.style.display = 'none';
        }
      });
    });

    function orientAndSizeUI() {
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        let logicalWidth, logicalHeight;
        // dpr is already global

        appContainer.style.transformOrigin = 'top left';

        if (vh > vw && vw < 768) { // Portrait on phone-like screens, force landscape
            isRotated = true;
            currentAppRotation = 90;
            // App container takes physical screen height as its logical width
            // and physical screen width as its logical height
            appContainer.style.width = vh + 'px'; 
            appContainer.style.height = vw + 'px';
            // This specific transform makes the app's original (0, vw) [bottom-left] 
            // appear at screen (0,0) [top-left of viewport].
            // The app's original X-axis runs down, Y-axis runs left (from screen top-right essentially).
            appContainer.style.transform = `rotate(${currentAppRotation}deg) translateY(-${vw}px)`;
            
            logicalWidth = vh; 
            logicalHeight = vw;
        } else { // Landscape or square, or large portrait (tablet/desktop)
            isRotated = false;
            currentAppRotation = 0;
            appContainer.style.width = vw + 'px';
            appContainer.style.height = vh + 'px';
            appContainer.style.transform = 'none';

            logicalWidth = vw;
            logicalHeight = vh;
        }

        displayCanvas.style.width = logicalWidth + 'px';
        displayCanvas.style.height = logicalHeight + 'px';
        
        let existingImageData = null;
        if(dataCanvas.width > 0 && dataCanvas.height > 0) {
            existingImageData = dataCtx.getImageData(0, 0, dataCanvas.width, dataCanvas.height);
        }

        displayCanvas.width = logicalWidth * dpr;
        displayCanvas.height = logicalHeight * dpr;
        dataCanvas.width = logicalWidth * dpr;
        dataCanvas.height = logicalHeight * dpr;

        // Apply DPR scaling to contexts. resetTransform() clears any previous transform.
        displayCtx.resetTransform(); 
        displayCtx.scale(dpr, dpr);
        dataCtx.resetTransform();
        dataCtx.scale(dpr, dpr);
        
        let stateToApply = null;
        if (undoStack.length > 0) {
            const lastUndoData = undoStack[undoStack.length - 1];
            // Check if last undo state matches new dimensions. If not, it's invalid.
            if (lastUndoData.width === dataCanvas.width && lastUndoData.height === dataCanvas.height) {
                stateToApply = lastUndoData;
            } else { 
                undoStack = []; // Invalidate stacks if dimensions change significantly
                redoStack = [];
            }
        } else if (existingImageData && 
                   existingImageData.width === dataCanvas.width && 
                   existingImageData.height === dataCanvas.height) {
            stateToApply = existingImageData; // Restore previous drawing if no undo history
        }
        
        // applyState will handle clearing if stateToApply is null, then redrawDisplayCanvas
        applyState(stateToApply); 
        updateUndoRedoButtons();
        
        if (controlsPanel.classList.contains('open')) {
            panelToggleBtn.textContent = '▼ Close';
            requestAnimationFrame(() => { // Ensure panel height is calculated after styles apply
                 panelToggleBtn.style.bottom = controlsPanel.offsetHeight + 'px';
            });
        } else {
            panelToggleBtn.textContent = '▲ Tools';
        }
        controlsPanel.style.maxHeight = (isRotated ? vw : vh) * 0.6 + 'px'; // Max height based on on-screen vertical space
    }


    function initApp() {
      initPalette();
      orientAndSizeUI(); 
      if (undoStack.length === 0 && redoStack.length === 0) {
          const initialData = dataCtx.getImageData(0,0,dataCanvas.width, dataCanvas.height);
          let isEmpty = true;
          for(let i=3; i < initialData.data.length; i+=4) { // Check alpha channel
              if(initialData.data[i] !== 0) {isEmpty = false; break;}
          }
          if(isEmpty) saveState(); // Save initial empty state
      }
      updateUndoRedoButtons();
      document.getElementById('brush-size-value').textContent = currentBrushSize;
      panelToggleBtn.textContent = '▲ Tools'; // Default panel state
    }

    initApp();
    window.addEventListener('resize', orientAndSizeUI);
    if (window.screen.orientation) {
        window.screen.orientation.addEventListener('change', orientAndSizeUI);
    } else {
        window.addEventListener('orientationchange', orientAndSizeUI); // For older browsers
    }

  </script>
</body>
</html>