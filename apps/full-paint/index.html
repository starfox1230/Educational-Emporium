<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Full-Res Painter</title>
  <style>
    body {
      margin: 0;
      background: #121212;
      color: #e0e0e0;
      font-family: sans-serif;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #app-container { /* New wrapper for potential rotation later */
      width: 100vw;
      height: 100vh;
      position: relative; /* For positioning children like panel */
      overflow: hidden; /* Contains the panel */
    }

    #canvas-container {
      margin: 0;
      width: 100%; /* Takes full width of app-container */
      height: 100%;/* Takes full height of app-container */
      position: absolute; /* Ensure it's layered correctly if panel overlaps */
      top: 0;
      left: 0;
    }

    canvas#paint-canvas { /* This is the display canvas */
      display: block;
      /* width/height attributes and style set by JS */
    }

    #brush-preview {
      position: fixed;
      border: 2px solid rgba(224, 224, 224, 0.7);
      border-radius: 50%;
      background-color: rgba(128, 128, 128, 0.3);
      pointer-events: none;
      display: none;
      z-index: 1000;
      box-sizing: border-box;
    }

    #controls-panel {
      position: absolute; /* Changed from fixed to be relative to app-container */
      bottom: 0;
      left: 0;
      width: 100%;
      background: #1a1a1a;
      z-index: 100;
      transform: translateY(100%);
      transition: transform 0.3s ease-out;
      padding: 20px 10px 10px 10px;
      box-sizing: border-box;
      max-height: 60%; /* % of app-container height */
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      border-top: 1px solid #333;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
    }

    #controls-panel.open {
      transform: translateY(0);
    }

    #panel-toggle-btn {
      position: absolute; /* Changed from fixed */
      left: 50%;
      bottom: 0px;
      transform: translateX(-50%);
      background: #6200ee;
      color: white;
      border: none;
      padding: 8px 20px;
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      cursor: pointer;
      z-index: 101;
      transition: bottom 0.3s ease-out, background-color 0.2s;
      font-size: 16px;
    }
    #panel-toggle-btn:hover {
      background: #7c4dff;
    }

    /* Styles for controls inside the panel (largely unchanged) */
    #controls-panel #controls { margin: 0 0 16px 0; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; width: 100%; }
    #controls-panel button { padding: 8px 12px; border: none; border-radius: 8px; background: #6200ee; color: white; cursor: pointer; transition: background-color 0.2s; }
    #controls-panel button:hover { background: #7c4dff; }
    #controls-panel button:disabled { background: #444; cursor: not-allowed; }
    #controls-panel #palette-container { display: flex; align-items: center; width: 100%; max-width: 500px; margin-bottom: 12px; }
    .eraser-btn-palette { width: 36px; height: 36px; border: 2px solid transparent; border-radius: 8px; cursor: pointer; transition: transform 0.1s, border-color 0.1s; background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 7px 7px; background-color: #fff; flex-shrink: 0; margin-right: 4px; }
    .eraser-btn-palette.selected { border-color: #e0e0e0; transform: scale(1.1); }
    #controls-panel #color-palette { display: flex; flex-direction: row; flex-wrap: nowrap; overflow-x: auto; padding: 6px 4px; background: #2c2c2c; border-radius: 10px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.5); flex-grow: 1; }
    #controls-panel .color-btn { width: 36px; height: 36px; border: 2px solid transparent; border-radius: 8px; cursor: pointer; transition: transform 0.1s; flex: 0 0 auto; margin-right: 4px; }
    #controls-panel .color-btn.selected { border-color: #e0e0e0; transform: scale(1.1); }
    #controls-panel .slider-group { width: 100%; max-width: 500px; margin-bottom: 12px; text-align: center; }
    #controls-panel .slider-group label { display: block; margin-bottom: 4px; font-size: 14px; }
    #controls-panel input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 10px; background: #444; outline: none; border-radius: 5px; margin-top: 4px; }
    #controls-panel input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #6200ee; border-radius: 50%; cursor: pointer; }
    #controls-panel input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #6200ee; border-radius: 50%; cursor: pointer; border: none; }
    #controls-panel #clear-toggle-container { width: 100%; max-width: 500px; margin-bottom: 10px; text-align: center; font-size: 15px; }

  </style>
</head>
<body>
  <div id="app-container">
    <div id="canvas-container">
      <canvas id="paint-canvas"></canvas> <!-- This is the display canvas -->
    </div>
    <div id="brush-preview"></div>

    <button id="panel-toggle-btn">â–² Tools</button>
    <div id="controls-panel">
      <div id="controls">
        <button id="clear-canvas-btn">Clear Canvas</button>
        <button id="undo-btn">Undo</button>
        <button id="redo-btn">Redo</button>
        <button id="save-btn">Save PNG</button>
      </div>
      <div class="slider-group">
        <label for="brush-size-slider">Brush Size: <span id="brush-size-value">5</span>px</label>
        <input type="range" id="brush-size-slider" min="1" max="100" value="5">
      </div>
      <div id="palette-container">
        <div id="color-palette"></div>
      </div>
      <div class="slider-group">
        <label for="brightness-slider">Color Brightness</label>
        <input type="range" id="brightness-slider" min="-50" max="50" value="0">
      </div>
      <div id="clear-toggle-container">
        <label>
          <input type="checkbox" id="clear-toggle">
          Depict Transparent as Black
        </label>
      </div>
    </div>
  </div>

  <script>
    const ERASER = "eraser";
    let brightnessOffset = 0;
    let depictClearAsBlack = false;

    const TOTAL_RAINBOW_COLORS = 32;
    const baseRainbowHues = Array.from({ length: TOTAL_RAINBOW_COLORS }, (_, i) => i * (360 / TOTAL_RAINBOW_COLORS));

    // --- Canvas Setup ---
    const displayCanvas = document.getElementById('paint-canvas');
    const displayCtx = displayCanvas.getContext('2d');

    const dataCanvas = document.createElement('canvas'); // Offscreen canvas for pure artwork
    const dataCtx = dataCanvas.getContext('2d', { willReadFrequently: true });

    const brushPreviewEl = document.getElementById('brush-preview');
    let brushPreviewTimeout;

    let selectedColor = 1; // Default: Black (index 1)
    let currentBrushSize = 5;
    let isDrawing = false;
    let lastX, lastY;
    let isRotated = false; // For landscape enforcement later

    let undoStack = [];
    let redoStack = [];
    const MAX_UNDO_STEPS = 20;

    document.addEventListener('contextmenu', e => e.preventDefault());

    // --- Palette Logic (same as before) ---
    function getPaletteColor(index) { /* ... no change ... */ }
    function buildPaletteScrollable() { /* ... no change ... */ }
    // --- End Palette Logic ---

    function getPaletteColor(index) {
      if (index === 0) return ERASER;
      if (index === 1) return "#000000";
      if (index === 2) return "#FFFFFF";
      if (index === 3) {
        let lightness = Math.min(100, Math.max(0, 50 + brightnessOffset));
        return `hsl(0, 0%, ${lightness}%)`;
      }
      let j = index - 4;
      let lightness = Math.min(100, Math.max(0, 50 + brightnessOffset));
      return `hsl(${baseRainbowHues[j % TOTAL_RAINBOW_COLORS]}, 100%, ${lightness}%)`;
    }

    function buildPaletteScrollable() {
      const palette = [];
      const totalPaletteColors = 3 + TOTAL_RAINBOW_COLORS;
      for (let i = 1; i <= totalPaletteColors; i++){
        palette.push(getPaletteColor(i));
      }
      return palette;
    }

    function redrawDisplayCanvas() {
      displayCtx.save(); // Save current state of displayCtx
      displayCtx.setTransform(1,0,0,1,0,0); // Reset transforms for clearing/filling

      if (depictClearAsBlack) {
        displayCtx.fillStyle = '#000000';
        displayCtx.fillRect(0, 0, displayCanvas.width, displayCanvas.height);
      } else {
        displayCtx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);
      }
      displayCtx.drawImage(dataCanvas, 0, 0);
      displayCtx.restore(); // Restore previous transforms if any (e.g. for DPR scaling)
    }

    function saveState() {
      if (undoStack.length >= MAX_UNDO_STEPS) {
        undoStack.shift();
      }
      // Save pure data from dataCanvas
      undoStack.push(dataCtx.getImageData(0, 0, dataCanvas.width, dataCanvas.height));
      redoStack = [];
      updateUndoRedoButtons();
    }

    function applyState(pureImageData) {
      if (pureImageData) {
        dataCtx.putImageData(pureImageData, 0, 0);
      } else {
        // Clear dataCanvas if null imageData (e.g. initial clear)
        dataCtx.clearRect(0, 0, dataCanvas.width, dataCanvas.height);
      }
      redrawDisplayCanvas();
      updateUndoRedoButtons();
    }
    
    function updateUndoRedoButtons() {
      document.getElementById('undo-btn').disabled = undoStack.length === 0;
      document.getElementById('redo-btn').disabled = redoStack.length === 0;
    }

    function getPointerPos(e) {
      const rect = displayCanvas.getBoundingClientRect();
      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      let canvasX = clientX - rect.left;
      let canvasY = clientY - rect.top;

      if (isRotated) { // Adjust coordinates if UI is rotated
          const tempX = canvasX;
          // For 90deg clockwise rotation: newX = canvasY, newY = displayCanvas.height (css) - canvasX
          canvasX = canvasY;
          canvasY = rect.width - tempX; // rect.width is original CSS height
      }
      
      // Scale to dataCanvas resolution
      // displayCanvas.width/height are attributes (buffer size)
      // rect.width/height are CSS rendered size on screen
      const scaleX = dataCanvas.width / rect.width;
      const scaleY = dataCanvas.height / rect.height;
      
      if (isRotated) {
          // When rotated, rect.width corresponds to logical height, rect.height to logical width
          const rotatedScaleX = dataCanvas.width / rect.height;
          const rotatedScaleY = dataCanvas.height / rect.width;
          return {
            x: canvasX * rotatedScaleX,
            y: canvasY * rotatedScaleY
          };
      } else {
         return {
            x: canvasX * scaleX,
            y: canvasY * scaleY
         };
      }
    }


    function startDrawing(e) {
      if (controlsPanel.classList.contains('open')) return;

      saveState(); // Saves current state of dataCanvas
      isDrawing = true;
      const pos = getPointerPos(e);
      [lastX, lastY] = [pos.x, pos.y];

      const actualColor = getPaletteColor(selectedColor);
      if (actualColor === ERASER) {
        dataCtx.globalCompositeOperation = 'destination-out';
      } else {
        dataCtx.globalCompositeOperation = 'source-over';
        dataCtx.strokeStyle = actualColor;
        dataCtx.fillStyle = actualColor; // For single dot
      }
      dataCtx.lineWidth = currentBrushSize;
      dataCtx.lineCap = 'round';
      dataCtx.lineJoin = 'round';

      // Draw on dataCtx
      dataCtx.beginPath();
      dataCtx.arc(lastX, lastY, currentBrushSize / 2, 0, Math.PI * 2);
      dataCtx.fill();
      dataCtx.beginPath(); // Prepare for line
      dataCtx.moveTo(lastX, lastY);

      redrawDisplayCanvas(); // Update visible canvas
    }

    function draw(e) {
      if (!isDrawing || controlsPanel.classList.contains('open')) return;
      const pos = getPointerPos(e);
      
      dataCtx.lineTo(pos.x, pos.y);
      dataCtx.stroke();
      
      dataCtx.beginPath(); // For smoother subsequent strokes
      dataCtx.moveTo(pos.x, pos.y);

      [lastX, lastY] = [pos.x, pos.y];
      redrawDisplayCanvas();
    }

    function stopDrawing() {
      if (!isDrawing) return;
      dataCtx.beginPath(); // End current path segment on dataCtx
      isDrawing = false;
      // No explicit redrawDisplayCanvas here, as last draw() or startDrawing() would have done it.
      // However, if a final dot or something was expected on mouseup without move, it might be needed.
      // Current logic for dot is in startDrawing, so this should be fine.
      updateUndoRedoButtons();
    }

    displayCanvas.addEventListener('mousedown', startDrawing);
    displayCanvas.addEventListener('mousemove', draw);
    document.addEventListener('mouseup', stopDrawing); // Global to catch mouseup outside canvas
    displayCanvas.addEventListener('mouseleave', stopDrawing); // If mouse leaves canvas while drawing

    displayCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); });
    displayCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); });
    document.addEventListener('touchend', stopDrawing); // Global for touchend


    document.getElementById('clear-canvas-btn').addEventListener('click', () => {
      saveState(); // Save current state of dataCanvas before clearing
      dataCtx.clearRect(0, 0, dataCanvas.width, dataCanvas.height); // Clear dataCanvas
      redrawDisplayCanvas(); // Update display
      // updateUndoRedoButtons() is called in applyState, which is implicitly part of this flow
    });

    document.getElementById('undo-btn').addEventListener('click', () => {
      if (undoStack.length > 0) {
        // Current dataCanvas state becomes a redo state
        redoStack.push(dataCtx.getImageData(0, 0, dataCanvas.width, dataCanvas.height));
        const prevState = undoStack.pop();
        applyState(prevState); // Applies to dataCanvas and redraws display
      }
    });

    document.getElementById('redo-btn').addEventListener('click', () => {
      if (redoStack.length > 0) {
        // Current dataCanvas state becomes an undo state
        undoStack.push(dataCtx.getImageData(0, 0, dataCanvas.width, dataCanvas.height));
        const nextState = redoStack.pop();
        applyState(nextState); // Applies to dataCanvas and redraws display
      }
    });

    document.getElementById('save-btn').addEventListener('click', () => {
      // dataCanvas already contains the pure image.
      // If depictClearAsBlack is true and user wants that in the PNG,
      // a temporary canvas would be needed to composite dataCanvas onto black.
      // For now, save the pure artwork with transparency.
      const randomStr = Math.random().toString(36).substring(2, 7);
      const link = document.createElement('a');
      link.download = `paint-art-${randomStr}.png`;
      link.href = dataCanvas.toDataURL('image/png'); // Save from dataCanvas
      link.click();
    });

    function selectColor(index) { /* ... no change from before ... */ }
    function initPalette() { /* ... no change from before ... */ }
    // --- UI Element Event Listeners (Sliders, Toggles, Panel) ---
    // These are largely the same, but `clear-toggle` now just calls `redrawDisplayCanvas`
     function selectColor(index) {
      selectedColor = index;
      document.querySelectorAll('.eraser-btn-palette, .color-btn').forEach(btn => btn.classList.remove('selected'));
      const selectedButton = document.querySelector(`#controls-panel [data-color="${index}"]`);
      if (selectedButton) selectedButton.classList.add('selected');
    }

    function initPalette() {
      const paletteContainer = document.getElementById('palette-container');
      const scrollablePalette = document.getElementById('color-palette');
      const scrollPos = scrollablePalette.scrollLeft;

      const existingEraser = paletteContainer.querySelector('.eraser-btn-palette');
      if (existingEraser) existingEraser.remove();
      scrollablePalette.innerHTML = '';

      const eraserBtn = document.createElement('button');
      eraserBtn.className = 'eraser-btn-palette';
      eraserBtn.dataset.color = "0";
      eraserBtn.addEventListener('click', () => selectColor(0));
      if (selectedColor == 0) eraserBtn.classList.add('selected');
      paletteContainer.prepend(eraserBtn);

      const scrollableColors = buildPaletteScrollable();
      scrollableColors.forEach((color, idx) => {
        const btn = document.createElement('button');
        btn.className = 'color-btn';
        const actualIndex = idx + 1;
        btn.dataset.color = actualIndex;
        btn.style.backgroundColor = color;
        btn.addEventListener('click', () => selectColor(actualIndex));
        if (selectedColor == actualIndex) btn.classList.add('selected');
        scrollablePalette.appendChild(btn);
      });
      scrollablePalette.scrollLeft = scrollPos;
    }
    
    const brushSizeSlider = document.getElementById('brush-size-slider');
    brushSizeSlider.addEventListener('input', (e) => {
      currentBrushSize = parseInt(e.target.value);
      document.getElementById('brush-size-value').textContent = currentBrushSize;

      const canvasRect = displayCanvas.getBoundingClientRect();
      // Brush size on dataCanvas needs to be scaled for preview on displayCanvas CSS pixels
      let cssBrushDiameter;
      if (isRotated) {
        // When rotated, displayCanvas's logical width is its CSS height
        cssBrushDiameter = currentBrushSize * (canvasRect.height / dataCanvas.width);
      } else {
        cssBrushDiameter = currentBrushSize * (canvasRect.width / dataCanvas.width);
      }

      brushPreviewEl.style.width = cssBrushDiameter + 'px';
      brushPreviewEl.style.height = cssBrushDiameter + 'px';
      
      // Centering logic needs to account for appContainer/viewport
      const appContainerRect = document.getElementById('app-container').getBoundingClientRect();
      if (isRotated) {
          // Center of rotated viewport
          brushPreviewEl.style.left = (appContainerRect.left + appContainerRect.width / 2 - cssBrushDiameter / 2) + 'px';
          brushPreviewEl.style.top = (appContainerRect.top + appContainerRect.height / 2 - cssBrushDiameter / 2) + 'px';
      } else {
          brushPreviewEl.style.left = (canvasRect.left + canvasRect.width / 2 - cssBrushDiameter / 2) + 'px';
          brushPreviewEl.style.top = (canvasRect.top + canvasRect.height / 2 - cssBrushDiameter / 2) + 'px';
      }
      brushPreviewEl.style.display = 'block';

      clearTimeout(brushPreviewTimeout);
      brushPreviewTimeout = setTimeout(() => {
        brushPreviewEl.style.display = 'none';
      }, 1500);
    });
    brushSizeSlider.addEventListener('change', () => {
        clearTimeout(brushPreviewTimeout);
        brushPreviewEl.style.display = 'none';
    });

    document.getElementById('brightness-slider').addEventListener('input', (e) => {
      brightnessOffset = parseInt(e.target.value);
      initPalette(); // Re-render palette with new brightness
    });

    document.getElementById('clear-toggle').addEventListener('change', (e) => {
      depictClearAsBlack = e.target.checked;
      redrawDisplayCanvas(); // Just update the display based on new preference
    });
    
    const controlsPanel = document.getElementById('controls-panel');
    const panelToggleBtn = document.getElementById('panel-toggle-btn');
    const appContainer = document.getElementById('app-container');

    panelToggleBtn.addEventListener('click', () => {
      controlsPanel.classList.toggle('open');
      const panelHeight = controlsPanel.offsetHeight; // Get actual height after styles apply
      if (controlsPanel.classList.contains('open')) {
        panelToggleBtn.textContent = isRotated ? 'â–¶ Close' : 'â–¼ Close';
        panelToggleBtn.style.bottom = panelHeight + 'px';
      } else {
        panelToggleBtn.textContent = isRotated ? 'â—€ Tools' : 'â–² Tools';
        panelToggleBtn.style.bottom = '0px';
        clearTimeout(brushPreviewTimeout);
        brushPreviewEl.style.display = 'none';
      }
    });
    // --- End UI Listeners ---

    function orientAndSizeUI() {
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        let logicalWidth, logicalHeight;

        if (vh > vw) { // Portrait mode - force landscape
            isRotated = true;
            appContainer.style.width = vh + 'px';
            appContainer.style.height = vw + 'px';
            appContainer.style.transformOrigin = 'top left';
            // To center after rotation:
            // translateX by (vh - vw) / 2
            // translateY by -(vw + (vh - vw) / 2) = -(vh+vw)/2
            // This is complex. Simpler: rotate around top-left then translate.
            // After rotation, top-left of element is at (0,0) but element's new width is vh, new height is vw.
            // It's now sticking out by 'vw' downwards. We need to shift it up by 'vw'.
            appContainer.style.transform = `rotate(90deg) translateY(-${vw}px)`;
            
            logicalWidth = vh; // Canvas content should span rotated width
            logicalHeight = vw; // Canvas content should span rotated height
            panelToggleBtn.textContent = controlsPanel.classList.contains('open') ? 'â–¶ Close' : 'â—€ Tools';
        } else { // Landscape or square
            isRotated = false;
            appContainer.style.width = vw + 'px';
            appContainer.style.height = vh + 'px';
            appContainer.style.transform = 'none';

            logicalWidth = vw;
            logicalHeight = vh;
            panelToggleBtn.textContent = controlsPanel.classList.contains('open') ? 'â–¼ Close' : 'â–² Tools';
        }

        // Set display canvas CSS size to fill its container (which might be appContainer directly or canvas-container)
        // displayCanvas is inside canvas-container, which is 100% of appContainer. So effectively fills appContainer.
        displayCanvas.style.width = logicalWidth + 'px';
        displayCanvas.style.height = logicalHeight + 'px';
        
        // Set canvas buffer size (attributes)
        // For simplicity, match buffer to logical CSS size. For DPR, multiply by devicePixelRatio.
        const dpr = window.devicePixelRatio || 1;
        displayCanvas.width = logicalWidth * dpr;
        displayCanvas.height = logicalHeight * dpr;
        dataCanvas.width = logicalWidth * dpr;
        dataCanvas.height = logicalHeight * dpr;

        // Scale contexts if using DPR
        displayCtx.setTransform(dpr, 0, 0, dpr, 0, 0); // Apply scaling for display
        dataCtx.setTransform(dpr, 0, 0, dpr, 0, 0);    // Apply scaling for data

        // Preserve existing drawing if possible (e.g., if only DPR changed, not logical size)
        // This is complex. For now, resizing will effectively clear or restore last full state if dims match.
        // A more robust solution would scale existing dataCtx content.
        let lastState = null;
        if(undoStack.length > 0) {
            // Check if last undo state dimensions match new dataCanvas dimensions
            const lastUndoData = undoStack[undoStack.length -1];
            if (lastUndoData.width === dataCanvas.width && lastUndoData.height === dataCanvas.height) {
                lastState = lastUndoData;
            } else { // Dimensions mismatch, previous undo stack is invalid for direct application
                undoStack = [];
                redoStack = [];
                updateUndoRedoButtons();
            }
        }
        applyState(lastState); // applyState clears dataCtx if lastState is null, then redraws display
        
        // Re-position panel toggle if panel is open
        if (controlsPanel.classList.contains('open')) {
            controlsPanel.style.maxHeight = (isRotated ? logicalWidth : logicalHeight) * 0.6 + 'px'; // 60% of new effective height
            panelToggleBtn.style.bottom = controlsPanel.offsetHeight + 'px';
        }
    }


    function initApp() {
      initPalette();
      orientAndSizeUI(); // This also calls applyState(null) if undo stack is empty.
      // Save initial empty state AFTER sizing and first applyState
      if (undoStack.length === 0) { // Ensure initial state is saved only if not restored
          saveState();
      }
      updateUndoRedoButtons();
      document.getElementById('brush-size-value').textContent = currentBrushSize;
    }

    initApp();
    window.addEventListener('resize', orientAndSizeUI);
    // Watch for orientation changes specifically for mobile, as resize might not always fire reliably or timely
    if (window.screen.orientation) {
        window.screen.orientation.addEventListener('change', orientAndSizeUI);
    } else { // Fallback for older browsers
        window.addEventListener('orientationchange', orientAndSizeUI);
    }

  </script>
</body>
</html>