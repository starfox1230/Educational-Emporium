<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>B or D - Letter Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1">
  <style>
    /* 
      ============================================
      CSS VARIABLES & GLOBAL STYLES
      ============================================
    */
    :root {
      --bg: #0d0d1a;
      --accent: #00e0ff;
      --heart-on: #ff4fa3;
      --heart-off: #4a4a5a;
      --text-glow: 0 0 6px var(--accent);
      /* NEW: Added a color for the combo bar */
      --combo-color: #fbc531;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background-color: var(--bg);
      color: var(--accent);
      font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      touch-action: manipulation;
      -ms-touch-action: manipulation;
    }

    canvas#game {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* 
      ============================================
      UI & HUD STYLES
      ============================================
    */
    #ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5vh 2vw;
      box-sizing: border-box;
    }

    .hud-top {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    #score-container {
      text-align: center;
      position: absolute;
      top: 1.5vh;
      left: 50%;
      transform: translateX(-50%);
    }

    #score {
      font-size: clamp(3rem, 10vw, 5rem);
      font-weight: bold;
      text-shadow: var(--text-glow);
    }
    
    #level-display {
      font-size: clamp(1rem, 4vw, 1.5rem);
      margin-top: -10px;
      opacity: 0.8;
    }

    #lives-container { display: flex; gap: 5px; }
    .heart { font-size: clamp(1.5rem, 6vw, 2.5rem); transition: all 0.3s ease; }
    .heart.on { color: var(--heart-on); text-shadow: 0 0 8px var(--heart-on); opacity: 1; }
    .heart.off { color: var(--heart-off); text-shadow: none; opacity: 0.6; }

    #replay-btn {
      font-size: clamp(1.8rem, 7vw, 3rem);
      background: none; border: none; color: var(--accent);
      cursor: pointer; pointer-events: auto; padding: 0;
      text-shadow: var(--text-glow); transition: transform 0.2s ease;
    }
    #replay-btn:active { transform: scale(0.9); }

    /* NEW: Styles for the bottom HUD elements */
    .hud-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: auto;
      pointer-events: none;
    }

    #combo-progress-bar {
      width: 100%;
      height: 10px;
      background-color: rgba(255, 255, 255, 0.1);
    }
    #combo-progress-bar-inner {
      width: 0%;
      height: 100%;
      background-color: var(--combo-color);
      box-shadow: 0 0 8px var(--combo-color);
      transition: width 0.3s ease-in-out;
    }

    #fruit-goal-container {
      position: absolute;
      bottom: 20px;
      right: 2vw;
      font-size: clamp(1.5rem, 5vw, 2.5rem);
      font-weight: bold;
      color: white;
      text-shadow: 0 0 5px black, 0 0 10px black;
    }

    /* 
      ============================================
      OVERLAY STYLES
      ============================================
    */
    .overlay {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(13, 13, 26, 0.85); backdrop-filter: blur(5px);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; color: var(--accent); z-index: 10;
      pointer-events: auto; opacity: 0; visibility: hidden;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }
    .overlay.visible { opacity: 1; visibility: visible; }
    .overlay h1 { font-size: clamp(2rem, 15vw, 6rem); margin: 0; text-shadow: var(--text-glow); animation: fadeIn 1s ease-out; }
    .overlay h2 { font-size: clamp(1.5rem, 8vw, 3rem); margin: 10px 0 30px; }
    .overlay .countdown { font-size: clamp(5rem, 25vw, 12rem); font-weight: bold; animation: countdown-pop 1s ease-out forwards; }
    .overlay button {
      font-size: clamp(1.2rem, 6vw, 2rem); padding: 15px 30px; border: 2px solid var(--accent);
      background-color: transparent; color: var(--accent); cursor: pointer; border-radius: 10px;
      text-shadow: var(--text-glow); transition: background-color 0.3s, color 0.3s;
    }
    .overlay button:hover, .overlay button:active { background-color: var(--accent); color: var(--bg); text-shadow: none; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes countdown-pop { 0% { transform: scale(0.5); opacity: 0; } 70% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); opacity: 1; } }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div class="hud-top">
      <button id="replay-btn" title="Replay Sound">üîä</button>
      <div id="score-container">
        <div id="score">0</div>
        <!-- NEW: This now just displays the level number -->
        <div id="level-display"></div>
      </div>
      <div id="lives-container">
        <span class="heart on">‚ù§</span><span class="heart on">‚ù§</span><span class="heart on">‚ù§</span><span class="heart on">‚ù§</span><span class="heart on">‚ù§</span>
      </div>
    </div>
    <div id="overlay" class="overlay"><div id="overlay-content"></div></div>
    
    <!-- NEW: Bottom part of the HUD for progress -->
    <div class="hud-bottom">
        <div id="fruit-goal-container"></div>
        <div id="combo-progress-bar">
            <div id="combo-progress-bar-inner"></div>
        </div>
    </div>
  </div>

  <!-- 
    NEW: Hidden audio elements for custom sounds.
    HOW TO USE YOUR OWN SOUNDS:
    1. Go to a website like "base64-encoder.net" or "base64.guru/converter/encode/audio".
    2. Upload your 'correct.mp3' file.
    3. Copy the entire Base64 string it generates.
    4. Paste it inside the src="" of the #audio-correct element, replacing the existing placeholder.
    5. Repeat for 'buzz.mp3' and the #audio-buzz element.
    The placeholders below are very short, quiet sounds.
  -->
  <audio id="audio-correct" src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjQ1LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAAB4aW5nAAAA/wAAABYAAAJ2YWRlIGluIG1zOjAsIHZhZGUgb3V0IG1zOjI1MAA//uQxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsYW1lAAAA/wAAAAAAAAA//uYxAAEAAANIAAAAAFhpbmcAAAADAAAAAAAACgAAA3YAAAAnDGGF2ZjU4LjQ1LjEwMAAAAAA//uUxAMgAAANIAAAAAFhpbmcAAAADAAAAAAAACgAAA3YAAAAnDGGF2ZjU4LjQ1LjEwMA=="></audio>
  <audio id="audio-buzz" src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjQ1LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAAB4aW5nAAAA/wAAABYAAAJ2YWRlIGluIG1zOjAsIHZhZGUgb3V0IG1zOjI1MAA//uQxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsYW1lAAAA/wAAAAAAAAA//uYxAAEAAANIAAAAAFhpbmcAAAADAAAAAAAACgAAA3YAAAAnDGGF2ZjU4LjQ1LjEwMAAAAAA//uUxAMgAAANIAAAAAFhpbmcAAAADAAAAAAAACgAAA3YAAAAnDGGF2ZjU4LjQ1LjEwMA=="></audio>

<script>
(function() {
  'use strict';

  // DOM Elements
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelDisplayEl = document.getElementById('level-display');
  const livesContainer = document.getElementById('lives-container');
  const heartElements = livesContainer.querySelectorAll('.heart');
  const replayBtn = document.getElementById('replay-btn');
  const overlay = document.getElementById('overlay');
  const overlayContent = document.getElementById('overlay-content');
  // NEW: UI elements for progress
  const comboProgressBarInner = document.getElementById('combo-progress-bar-inner');
  const fruitGoalContainer = document.getElementById('fruit-goal-container');
  // NEW: Audio elements
  const audioCorrect = document.getElementById('audio-correct');
  const audioBuzz = document.getElementById('audio-buzz');

  // Game State
  let gameState = 'loading';
  let score = 0, lives = 5, level = 1;
  const maxLevels = 10;
  
  // NEW: Game mechanic state variables
  let comboCounter = 0;
  const COMBO_GOAL = 4;
  let fruitsCollected = 0;
  const FRUITS_PER_LEVEL = 5;
  const levelFruits = ['üçì', 'üçé', 'üçâ', 'üçá', 'üçä', 'üçç', 'üçë', 'üçí', 'ü•ù', 'ü•≠'];

  // Level State
  let targetLetter = '', targetCase = 'upper';
  let targetSpawnerId, distractorSpawnerId, lifeSpawnerId;

  // Game Objects
  let sprites = [], effects = [];
  const fonts = ['Arial', 'Verdana', 'Georgia', 'Courier New', 'Times New Roman', 'Impact'];
  let screenShake = { duration: 0, magnitude: 0 };
  
  // Audio
  let voices = [], ttsUtterance = new SpeechSynthesisUtterance();
  ttsUtterance.rate = 0.9; ttsUtterance.pitch = 1.1;

  /*
    ============================================
    AUDIO & HELPER FUNCTIONS
    ============================================
  */
  
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function speak(text) {
    if (!window.speechSynthesis) return;
    speechSynthesis.cancel();
    ttsUtterance.text = text;
    speechSynthesis.speak(ttsUtterance);
  }

  function setupTTS() { /* ... unchanged ... */ } // (Keeping it folded for brevity)

  // NEW: Functions now play the HTML audio elements
  function playCorrectSound() {
      audioCorrect.currentTime = 0;
      audioCorrect.play().catch(e => console.log("Audio play failed:", e));
  }
  function playIncorrectSound() {
      audioBuzz.currentTime = 0;
      audioBuzz.play().catch(e => console.log("Audio play failed:", e));
  }
  
  const rand = (min, max) => Math.random() * (max - min) + min;
  const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];
  
  function clearSpawners() {
    clearInterval(targetSpawnerId);
    clearInterval(distractorSpawnerId);
    clearInterval(lifeSpawnerId);
  }

  /*
    ============================================
    SPRITE & EFFECT MANAGEMENT
    ============================================
  */

  // NEW: Modified to accept an optional glyph for spawning specific fruits
  function createSprite(type, glyphOverride = null) {
    const size = rand(canvas.height * 0.08, canvas.height * 0.15);
    const font = randChoice(fonts);
    let glyph = glyphOverride;

    if (!glyph) {
        if (type === 'penalty') glyph = randChoice(['üí£', 'üí•', 'ü¶à']);
        else if (type === 'life') glyph = '‚ù§';
        else {
          glyph = type === 'target' ? targetLetter : (targetLetter === 'B' ? 'D' : 'B');
          if (targetCase === 'lower') glyph = glyph.toLowerCase();
        }
    }

    ctx.font = `bold ${size}px ${font}`;
    const metrics = ctx.measureText(glyph);
    sprites.push({
      type, glyph, size, font,
      x: rand(metrics.width, canvas.width - metrics.width), y: rand(size, canvas.height - size),
      vx: rand(-1.5, 1.5) * (1 + level * 0.1), vy: rand(-1.5, 1.5) * (1 + level * 0.1),
      width: metrics.width, height: size,
      color: type === 'target' || type === 'wrong' ? `hsl(${rand(0,360)}, 100%, 75%)` : '#ff4fa3'
    });
  }

  function createEffect(type, x, y) { /* ... unchanged ... */ } // (Folded for brevity)

  /*
    ============================================
    GAME FLOW & STATE CHANGES
    ============================================
  */
  
  function resetGame() {
    score = 0; lives = 5; level = 1;
    sprites = []; effects = [];
    clearSpawners();
    updateScoreUI(); updateLivesUI();
    startIntro();
  }

  function startIntro() {
    gameState = 'intro';
    sprites = []; effects = [];
    if (level === 1 && lives === 5) {
      overlayContent.innerHTML = `
        <h1>B or D</h1>
        <h2>Tap 4 correct letters in a row to spawn a fruit. Collect 5 fruits to pass the level!</h2>
        <button id="start-btn">Start Game</button>
      `;
      document.getElementById('start-btn').onclick = startCountdown;
    } else {
        overlayContent.innerHTML = `<h1>LEVEL ${level}</h1>`;
        setTimeout(startCountdown, 2000);
    }
    overlay.classList.add('visible');
  }

  function startCountdown() { /* ... unchanged ... */ } // (Folded for brevity)

  function startLevel() {
    gameState = 'playing';
    targetLetter = randChoice(['B', 'D']);
    targetCase = randChoice(['upper', 'lower']);
    
    // NEW: Reset level progress
    comboCounter = 0;
    fruitsCollected = 0;
    updateComboProgressBar();
    updateFruitGoalUI();
    updateLevelDisplay();

    speak(targetLetter === 'B' ? 'Bee' : 'Dee');

    // NEW: Reduced initial sprite count for a gentler start
    const initialSpriteCount = 6 + level;
    for(let i = 0; i < initialSpriteCount; i++) {
        createSprite(Math.random() < 0.6 ? 'target' : 'wrong'); // Slightly more targets initially
    }
    
    clearSpawners();
    targetSpawnerId = setInterval(() => { /* ... unchanged ... */ }, 4000);
    distractorSpawnerId = setInterval(() => { /* ... unchanged ... */ }, 2000);
    lifeSpawnerId = setInterval(() => { /* ... unchanged ... */ }, 20000);
  }

  function endLevel() {
    gameState = 'levelEnd';
    clearSpawners();
    
    // NEW: Updated TTS message for level completion.
    const message = level >= maxLevels 
        ? "Congratulations, you win!" 
        : `Congratulations! Now moving on to level ${level + 1}`;
    speak(message);

    if (level >= maxLevels) {
        setTimeout(showVictory, 1000);
    } else {
        level++;
        // Wait a bit longer to let the TTS finish before showing the overlay
        setTimeout(startIntro, 3000);
    }
  }
  
  function showGameOver() { /* ... unchanged ... */ }
  function showVictory() { /* ... unchanged ... */ }

  /*
    ============================================
    UI UPDATE FUNCTIONS
    ============================================
  */
  function updateScoreUI() { scoreEl.textContent = score; }
  function updateLivesUI() { /* ... unchanged ... */ }
  
  // NEW: Function to update the level display
  function updateLevelDisplay() {
      levelDisplayEl.textContent = `Level ${level}`;
  }

  // NEW: Function to update the combo progress bar
  function updateComboProgressBar() {
      const percentage = (comboCounter / COMBO_GOAL) * 100;
      comboProgressBarInner.style.width = `${percentage}%`;
  }

  // NEW: Function to update the fruit goal tracker
  function updateFruitGoalUI() {
      const currentFruit = levelFruits[level - 1] || '‚≠ê';
      fruitGoalContainer.innerHTML = `${currentFruit} ${fruitsCollected} / ${FRUITS_PER_LEVEL}`;
  }


  /*
    ============================================
    INPUT HANDLING
    ============================================
  */

  function handlePointerDown(e) {
    e.preventDefault();
    if (gameState !== 'playing') return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;

    for (let i = sprites.length - 1; i >= 0; i--) {
      const s = sprites[i];
      if (x > s.x - s.width / 2 && x < s.x + s.width / 2 && y > s.y - s.height / 2 && y < s.y + s.height) {
        
        // NEW: Major logic overhaul for combo system
        let mistake = false;

        switch(s.type) {
          case 'target':
            score += 10;
            comboCounter++;
            updateComboProgressBar();
            createEffect('correctBurst', s.x, s.y);
            playCorrectSound();
            if (comboCounter >= COMBO_GOAL) {
                // Spawn the level-specific fruit
                createSprite('bonus', levelFruits[level - 1] || '‚≠ê');
                comboCounter = 0;
                updateComboProgressBar();
            }
            break;
          case 'wrong':
          case 'penalty':
            mistake = true;
            score = Math.max(0, s.type === 'wrong' ? score - 10 : score - 50);
            lives--;
            const effectType = s.type === 'wrong' ? 'error' : 'explosion';
            createEffect(effectType, s.x, s.y);
            playIncorrectSound(); updateLivesUI();
            break;
          case 'bonus': // This is now only the level fruit
            fruitsCollected++;
            score += 50;
            updateFruitGoalUI();
            createEffect('confetti', s.x, s.y);
            playCorrectSound();
            if (fruitsCollected >= FRUITS_PER_LEVEL) {
                endLevel();
            }
            break;
          case 'life':
            if (lives < 5) {
                lives++; updateLivesUI();
                createEffect('heartBurst', s.x, s.y);
                playCorrectSound();
            }
            break;
        }

        if (mistake) {
            comboCounter = 0;
            updateComboProgressBar();
            if (s.type === 'penalty') {
                screenShake = { duration: 10, magnitude: 8 };
            }
        }
        
        updateScoreUI(); sprites.splice(i, 1); return;
      }
    }
  }

  /*
    ============================================
    GAME LOOP (UPDATE & DRAW)
    ============================================
  */
  function updateSprites() { /* ... unchanged ... */ }
  function updateEffects() { /* ... unchanged ... */ }
  function drawSprites() { /* ... unchanged ... */ }
  function drawEffects() { /* ... unchanged ... */ }
  function mainLoop() { /* ... unchanged ... */ }

  /*
    ============================================
    INITIALIZATION
    ============================================
  */
  
  function init() {
    resizeCanvas(); setupTTS();
    window.addEventListener('resize', resizeCanvas);
    canvas.addEventListener('pointerdown', e => {
        // This is a good place to ensure audio is enabled by the first tap
        // It's a fallback for the start button
        if(audioCorrect.paused) { /* A simple check */ }
        handlePointerDown(e);
    });
    replayBtn.addEventListener('click', () => {
        if (gameState === 'playing') {
            speak(targetLetter === 'B' ? 'Bee' : 'Dee');
        }
    });
    startIntro();
    requestAnimationFrame(mainLoop);
  }

  init();

})();
</script>
</body>
</html>