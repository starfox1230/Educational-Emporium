<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>B or D - Letter Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1">
  <style>
    /* 
      ============================================
      CSS VARIABLES & GLOBAL STYLES
      ============================================
    */
    :root {
      --bg: #0d0d1a;
      --accent: #00e0ff;
      --heart-on: #ff4fa3;
      --heart-off: #4a4a5a;
      --text-glow: 0 0 6px var(--accent);
      --combo-color: #fbc531;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background-color: var(--bg);
      color: var(--accent);
      font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      touch-action: manipulation;
      -ms-touch-action: manipulation;
    }

    canvas#game {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* 
      ============================================
      UI & HUD STYLES
      ============================================
    */
    #ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1.5vh 2vw;
      box-sizing: border-box;
    }

    .hud-top {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    #score-container {
      text-align: center;
      position: absolute;
      top: 1.5vh;
      left: 50%;
      transform: translateX(-50%);
    }

    #score {
      font-size: clamp(3rem, 10vw, 5rem);
      font-weight: bold;
      text-shadow: var(--text-glow);
    }
    
    #level-display {
      font-size: clamp(1rem, 4vw, 1.5rem);
      margin-top: -10px;
      opacity: 0.8;
    }

    #lives-container { display: flex; gap: 5px; }
    .heart { font-size: clamp(1.5rem, 6vw, 2.5rem); transition: all 0.3s ease; }
    .heart.on { color: var(--heart-on); text-shadow: 0 0 8px var(--heart-on); opacity: 1; }
    .heart.off { color: var(--heart-off); text-shadow: none; opacity: 0.6; }

    #replay-btn {
      font-size: clamp(1.8rem, 7vw, 3rem);
      background: none; border: none; color: var(--accent);
      cursor: pointer; pointer-events: auto; padding: 0;
      text-shadow: var(--text-glow); transition: transform 0.2s ease;
    }
    #replay-btn:active { transform: scale(0.9); }

    .hud-bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: auto;
      pointer-events: none;
    }

    #combo-progress-bar {
      width: 100%;
      height: 10px;
      background-color: rgba(255, 255, 255, 0.1);
    }
    #combo-progress-bar-inner {
      width: 0%;
      height: 100%;
      background-color: var(--combo-color);
      box-shadow: 0 0 8px var(--combo-color);
      transition: width 0.3s ease-in-out;
    }

    #fruit-goal-container {
      position: absolute;
      bottom: 20px;
      right: 2vw;
      font-size: clamp(1.5rem, 5vw, 2.5rem);
      font-weight: bold;
      color: white;
      text-shadow: 0 0 5px black, 0 0 10px black;
    }

    /* 
      ============================================
      OVERLAY STYLES
      ============================================
    */
    .overlay {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(13, 13, 26, 0.85); backdrop-filter: blur(5px);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; color: var(--accent); z-index: 10;
      pointer-events: auto; opacity: 0; visibility: hidden;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }
    .overlay.visible { opacity: 1; visibility: visible; }
    .overlay h1 { font-size: clamp(2rem, 15vw, 6rem); margin: 0; text-shadow: var(--text-glow); animation: fadeIn 1s ease-out; }
    .overlay h2 { font-size: clamp(1.5rem, 8vw, 3rem); margin: 10px 0 30px; }
    .overlay .countdown { font-size: clamp(5rem, 25vw, 12rem); font-weight: bold; animation: countdown-pop 1s ease-out forwards; }
    .overlay button {
      font-size: clamp(1.2rem, 6vw, 2rem); padding: 15px 30px; border: 2px solid var(--accent);
      background-color: transparent; color: var(--accent); cursor: pointer; border-radius: 10px;
      text-shadow: var(--text-glow); transition: background-color 0.3s, color 0.3s;
    }
    .overlay button:hover, .overlay button:active { background-color: var(--accent); color: var(--bg); text-shadow: none; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes countdown-pop { 0% { transform: scale(0.5); opacity: 0; } 70% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); opacity: 1; } }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div class="hud-top">
      <button id="replay-btn" title="Replay Sound">üîä</button>
      <div id="score-container">
        <div id="score">0</div>
        <div id="level-display"></div>
      </div>
      <div id="lives-container">
        <span class="heart on">‚ù§</span><span class="heart on">‚ù§</span><span class="heart on">‚ù§</span><span class="heart on">‚ù§</span><span class="heart on">‚ù§</span>
      </div>
    </div>
    <div id="overlay" class="overlay"><div id="overlay-content"></div></div>
    
    <div class="hud-bottom">
        <div id="fruit-goal-container"></div>
        <div id="combo-progress-bar">
            <div id="combo-progress-bar-inner"></div>
        </div>
    </div>
  </div>

  <!-- 
    NEW: Audio elements for specific letter sounds.
    REPLACE the src with your own Base64 encoded mp3 files.
  -->
  <audio id="audio-b-correct" src="data:audio/mpeg;base64,SUQz..."></audio>
  <audio id="audio-b-wrong" src="data:audio/mpeg;base64,SUQz..."></audio>
  <audio id="audio-d-correct" src="data:audio/mpeg;base64,SUQz..."></audio>
  <audio id="audio-d-wrong" src="data:audio/mpeg;base64,SUQz..."></audio>
  
  <!-- MODIFIED: These are now for bonus/penalty sounds only -->
  <audio id="audio-bonus" src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjQ1LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAAB4aW5nAAAA/wAAABYAAAJ2YWRlIGluIG1zOjAsIHZhZGUgb3V0IG1zOjI1MAA//uQxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsYW1lAAAA/wAAAAAAAAA//uYxAAEAAANIAAAAAFhpbmcAAAADAAAAAAAACgAAA3YAAAAnDGGF2ZjU4LjQ1LjEwMAAAAAA//uUxAMgAAANIAAAAAFhpbmcAAAADAAAAAAAACgAAA3YAAAAnDGGF2ZjU4LjQ1LjEwMA=="></audio>
  <audio id="audio-penalty" src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjQ1LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAAB4aW5nAAAA/wAAABYAAAJ2YWRlIGluIG1zOjAsIHZhZGUgb3V0IG1zOjI1MAA//uQxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsYW1lAAAA/wAAAAAAAAA//uYxAAEAAANIAAAAAFhpbmcAAAADAAAAAAAACgAAA3YAAAAnDGGF2ZjU4LjQ1LjEwMAAAAAA//uUxAMgAAANIAAAAAFhpbmcAAAADAAAAAAAACgAAA3YAAAAnDGGF2ZjU4LjQ1LjEwMA=="></audio>

<script>
(function() {
  'use strict';

  // DOM Elements
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelDisplayEl = document.getElementById('level-display');
  const livesContainer = document.getElementById('lives-container');
  const heartElements = livesContainer.querySelectorAll('.heart');
  const replayBtn = document.getElementById('replay-btn');
  const overlay = document.getElementById('overlay');
  const overlayContent = document.getElementById('overlay-content');
  const comboProgressBar = document.getElementById('combo-progress-bar');
  const comboProgressBarInner = document.getElementById('combo-progress-bar-inner');
  const fruitGoalContainer = document.getElementById('fruit-goal-container');
  
  // NEW: Get all audio elements
  const audioBCorrect = document.getElementById('audio-b-correct');
  const audioBWrong = document.getElementById('audio-b-wrong');
  const audioDCorrect = document.getElementById('audio-d-correct');
  const audioDWrong = document.getElementById('audio-d-wrong');
  const audioBonus = document.getElementById('audio-bonus');
  const audioPenalty = document.getElementById('audio-penalty');

  // Game State
  let gameState = 'loading', score = 0, lives = 5, level = 1;
  const maxLevels = 10;
  let playAreaBottom = window.innerHeight;

  // Game mechanic state variables
  let comboCounter = 0; const COMBO_GOAL = 4;
  let fruitsCollected = 0; const FRUITS_PER_LEVEL = 5;
  const levelFruits = ['üçì', 'üçé', 'üçâ', 'üçá', 'üçä', 'üçç', 'üçë', 'üçí', 'ü•ù', 'ü•≠'];

  // Level State
  let targetLetter = '', targetCase = 'upper';
  let targetSpawnerId, distractorSpawnerId, lifeSpawnerId;

  // Game Objects
  let sprites = [], effects = [];
  const fonts = ['Arial', 'Verdana', 'Georgia', 'Courier New', 'Times New Roman', 'Impact'];
  let screenShake = { duration: 0, magnitude: 0 };
  
  // Audio
  let voices = [], ttsUtterance = new SpeechSynthesisUtterance();
  ttsUtterance.rate = 0.9; ttsUtterance.pitch = 1.1;

  /*
    ============================================
    AUDIO & HELPER FUNCTIONS
    ============================================
  */
  
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const progressBarHeight = comboProgressBar.offsetHeight || 10;
    playAreaBottom = canvas.height - progressBarHeight - 5;
  }

  function speak(text) {
    if (!window.speechSynthesis) return;
    speechSynthesis.cancel();
    ttsUtterance.text = text;
    speechSynthesis.speak(ttsUtterance);
  }

  function setupTTS() {
    function loadVoices() {
      voices = speechSynthesis.getVoices();
      if (voices.length > 0) {
        const preferredVoice = voices.find(v => v.lang.startsWith('en') && v.localService) || voices.find(v => v.lang.startsWith('en'));
        if (preferredVoice) ttsUtterance.voice = preferredVoice;
      }
    }
    loadVoices();
    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = loadVoices;
    }
  }
  
  // MODIFIED: Renamed for clarity. These now only play for non-letter interactions.
  function playBonusSound() {
      audioBonus.currentTime = 0;
      audioBonus.play().catch(e => console.log("Audio play failed:", e));
  }
  function playPenaltySound() {
      audioPenalty.currentTime = 0;
      audioPenalty.play().catch(e => console.log("Audio play failed:", e));
  }
  
  const rand = (min, max) => Math.random() * (max - min) + min;
  const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];
  
  function clearSpawners() {
    clearInterval(targetSpawnerId);
    clearInterval(distractorSpawnerId);
    clearInterval(lifeSpawnerId);
  }

  /*
    ============================================
    SPRITE & EFFECT MANAGEMENT
    ============================================
  */

  function createSprite(type, glyphOverride = null) {
    const size = rand(canvas.height * 0.08, canvas.height * 0.15);
    const font = randChoice(fonts);
    let glyph = glyphOverride;

    if (!glyph) {
        if (type === 'penalty') glyph = 'üí£';
        else if (type === 'life') glyph = '‚ù§';
        else {
          glyph = type === 'target' ? targetLetter : (targetLetter === 'B' ? 'D' : 'B');
          if (targetCase === 'lower') glyph = glyph.toLowerCase();
        }
    }

    ctx.font = `bold ${size}px ${font}`;
    const metrics = ctx.measureText(glyph);
    sprites.push({
      type, glyph, size, font,
      x: rand(metrics.width / 2, canvas.width - metrics.width / 2), 
      y: rand(size / 2, playAreaBottom - size / 2),
      vx: rand(-1.5, 1.5) * (1 + level * 0.1), vy: rand(-1.5, 1.5) * (1 + level * 0.1),
      width: metrics.width, height: size,
      color: type === 'target' || type === 'wrong' ? `hsl(${rand(0,360)}, 100%, 75%)` : '#ff4fa3'
    });
  }

  function createEffect(type, x, y) {
    const effect = { type, x, y, life: 1 };
    if (type === 'correctBurst') {
        effect.radius = 0; effect.maxRadius = 50; effect.color = '#2ed573';
    } else if (type === 'heartBurst') {
        effect.radius = 0; effect.maxRadius = 50; effect.color = 'var(--heart-on)';
    } else if (type === 'error') {
        effect.radius = 0; effect.maxRadius = 60; effect.color = '#ff4757';
    } else if (type === 'confetti') {
      effect.particles = [];
      for (let i = 0; i < 30; i++) {
        effect.particles.push({
          x: 0, y: 0, vx: rand(-10, 10), vy: rand(-15, -5),
          w: rand(5, 10), h: rand(5, 10), life: 1, color: `hsl(${rand(0,360)}, 100%, 70%)`
        });
      }
    } else if (type === 'explosion') {
      screenShake = { duration: 15, magnitude: 15 };
    }
    effects.push(effect);
  }

  /*
    ============================================
    GAME FLOW & STATE CHANGES
    ============================================
  */
  
  function resetGame() {
    score = 0; lives = 5; level = 1;
    sprites = []; effects = [];
    clearSpawners();
    updateScoreUI(); updateLivesUI();
    startIntro();
  }

  function startIntro() {
    gameState = 'intro';
    sprites = []; effects = [];
    if (level === 1 && lives === 5) {
      overlayContent.innerHTML = `
        <h1>B or D</h1>
        <h2>Tap 4 correct letters in a row to spawn a fruit. Collect 5 fruits to pass the level!</h2>
        <button id="start-btn">Start Game</button>
      `;
      document.getElementById('start-btn').onclick = startCountdown;
    } else {
        overlayContent.innerHTML = `<h1>LEVEL ${level}</h1>`;
        setTimeout(startCountdown, 2000);
    }
    overlay.classList.add('visible');
  }

  function startCountdown() {
    gameState = 'countdown';
    let count = 3;
    function doCount() {
      if (count > 0) {
        overlayContent.innerHTML = `<div class="countdown">${count}</div>`;
        speak(String(count--));
        setTimeout(doCount, 1000);
      } else {
        overlay.classList.remove('visible');
        startLevel();
      }
    }
    doCount();
  }

  function startLevel() {
    gameState = 'playing';
    targetLetter = randChoice(['B', 'D']);
    targetCase = randChoice(['upper', 'lower']);
    
    comboCounter = 0;
    fruitsCollected = 0;
    updateComboProgressBar();
    updateFruitGoalUI();
    updateLevelDisplay();

    speak(targetLetter === 'B' ? 'Bee' : 'Dee');

    const initialSpriteCount = 6 + level;
    for(let i = 0; i < initialSpriteCount; i++) {
        createSprite(Math.random() < 0.6 ? 'target' : 'wrong');
    }
    
    clearSpawners();
    targetSpawnerId = setInterval(() => {
        if (gameState === 'playing' && sprites.filter(s => s.type === 'target').length < 15) {
            createSprite('target');
        }
    }, 4000);

    distractorSpawnerId = setInterval(() => {
        if (gameState === 'playing' && sprites.length < 40) {
            if (Math.random() < 0.2 + level * 0.04) {
                 createSprite('penalty');
            }
        }
    }, 2000);
    
    lifeSpawnerId = setInterval(() => {
        if (gameState === 'playing' && lives < 5 && !sprites.some(s => s.type === 'life')) {
            createSprite('life');
        }
    }, 20000);
  }

  function endLevel() {
    gameState = 'levelEnd';
    clearSpawners();
    
    const message = level >= maxLevels 
        ? "Congratulations, you win!" 
        : `Congratulations! Now moving on to level ${level + 1}`;
    speak(message);

    if (level >= maxLevels) {
        setTimeout(showVictory, 1000);
    } else {
        level++;
        setTimeout(startIntro, 3000);
    }
  }
  
  function showGameOver() {
    gameState = 'gameOver';
    clearSpawners();
    speak("Game Over");
    overlayContent.innerHTML = `
      <h1>GAME OVER</h1><h2>Final Score: ${score}</h2><button id="restart-btn">Restart</button>`;
    document.getElementById('restart-btn').onclick = resetGame;
    overlay.classList.add('visible');
  }

  function showVictory() {
    gameState = 'victory';
    clearSpawners();
    overlayContent.innerHTML = `
      <h1>YOU WIN!</h1><h2>Final Score: ${score}</h2><button id="play-again-btn">Play Again</button>`;
    document.getElementById('play-again-btn').onclick = resetGame;
    overlay.classList.add('visible');
  }

  /*
    ============================================
    UI UPDATE FUNCTIONS
    ============================================
  */
  function updateScoreUI() { scoreEl.textContent = score; }
  
  function updateLivesUI() {
    heartElements.forEach((heart, i) => {
      heart.textContent = i < lives ? '‚ù§' : '‚ô°';
      heart.className = `heart ${i < lives ? 'on' : 'off'}`;
    });
    if (lives <= 0 && gameState === 'playing') showGameOver();
  }
  
  function updateLevelDisplay() {
      levelDisplayEl.textContent = `Level ${level}`;
  }

  function updateComboProgressBar() {
      const percentage = (comboCounter / COMBO_GOAL) * 100;
      comboProgressBarInner.style.width = `${percentage}%`;
  }

  function updateFruitGoalUI() {
      const currentFruit = levelFruits[level - 1] || '‚≠ê';
      fruitGoalContainer.innerHTML = `${currentFruit} ${fruitsCollected} / ${FRUITS_PER_LEVEL}`;
  }

  /*
    ============================================
    INPUT HANDLING
    ============================================
  */

  function handlePointerDown(e) {
    e.preventDefault();
    if (gameState !== 'playing') return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;

    for (let i = sprites.length - 1; i >= 0; i--) {
      const s = sprites[i];
      if (x > s.x - s.width / 2 && x < s.x + s.width / 2 && y > s.y - s.height / 2 && y < s.y + s.height) {
        
        let mistake = false;
        const tappedSpriteType = s.type;

        switch(tappedSpriteType) {
          case 'target':
            score += 10;
            comboCounter++;
            updateComboProgressBar();
            createEffect('correctBurst', s.x, s.y);
            // NEW: Play specific correct sound based on letter
            if (s.glyph.toUpperCase() === 'B') {
                audioBCorrect.currentTime = 0;
                audioBCorrect.play().catch(e => console.log(e));
            } else { // It's a D
                audioDCorrect.currentTime = 0;
                audioDCorrect.play().catch(e => console.log(e));
            }
            if (comboCounter >= COMBO_GOAL) {
                createSprite('bonus', levelFruits[level - 1] || '‚≠ê');
                comboCounter = 0;
                updateComboProgressBar();
            }
            break;
          case 'wrong':
            mistake = true;
            score = Math.max(0, score - 10);
            lives--;
            createEffect('error', s.x, s.y);
            // NEW: Play specific wrong sound based on letter
            if (s.glyph.toUpperCase() === 'B') {
                audioBWrong.currentTime = 0;
                audioBWrong.play().catch(e => console.log(e));
            } else { // It's a D
                audioDWrong.currentTime = 0;
                audioDWrong.play().catch(e => console.log(e));
            }
            updateLivesUI();
            break;
          case 'penalty':
            mistake = true;
            score = Math.max(0, score - 50);
            lives--;
            createEffect('explosion', s.x, s.y);
            playPenaltySound(); // MODIFIED: Use generic penalty sound
            updateLivesUI();
            break;
          case 'bonus':
            fruitsCollected++;
            score += 50;
            updateFruitGoalUI();
            createEffect('confetti', s.x, s.y);
            playBonusSound(); // MODIFIED: Use generic bonus sound
            if (fruitsCollected >= FRUITS_PER_LEVEL) {
                endLevel();
            }
            break;
          case 'life':
            if (lives < 5) {
                lives++; updateLivesUI();
                createEffect('heartBurst', s.x, s.y);
                playBonusSound(); // MODIFIED: Use generic bonus sound
            }
            break;
        }

        if (mistake) {
            comboCounter = 0;
            updateComboProgressBar();
            if (tappedSpriteType === 'penalty') {
                screenShake = { duration: 10, magnitude: 8 };
            }
        }
        
        updateScoreUI();
        sprites.splice(i, 1);
        
        if (tappedSpriteType === 'target') {
            const targetsRemaining = sprites.some(sprite => sprite.type === 'target');
            if (!targetsRemaining) {
                for (let j = 0; j < 3; j++) {
                    createSprite('target');
                }
            }
        }
        
        return;
      }
    }
  }

  /*
    ============================================
    GAME LOOP (UPDATE & DRAW)
    ============================================
  */
  function updateSprites() {
    sprites.forEach(s => {
      s.x += s.vx;
      s.y += s.vy;
      
      if (s.x - s.width / 2 < 0 || s.x + s.width / 2 > canvas.width) {
          s.vx *= -1;
      }
      
      if (s.y - s.height < 0) { // Check top edge
          s.y = s.height;
          s.vy *= -1;
      } else if (s.y > playAreaBottom) { // Check bottom edge (play area)
          s.y = playAreaBottom;
          s.vy *= -1;
      }
    });
  }
  
  function updateEffects() {
    for (let i = effects.length - 1; i >= 0; i--) {
      const e = effects[i];
      e.life -= 0.03;
      if (e.life <= 0) { effects.splice(i, 1); continue; }
      if (e.type === 'correctBurst' || e.type === 'heartBurst' || e.type === 'error') e.radius += 3;
      if (e.type === 'confetti') {
        e.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= 0.03; });
      }
    }
  }

  function drawSprites() {
    sprites.forEach(s => {
      ctx.font = `bold ${s.size}px ${s.font}`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = s.color;
      ctx.fillText(s.glyph, s.x, s.y);
    });
  }

  function drawEffects() {
    effects.forEach(e => {
      ctx.globalAlpha = e.life;
      if (e.type === 'correctBurst' || e.type === 'heartBurst' || e.type === 'error') {
        ctx.strokeStyle = e.color; ctx.lineWidth = 5 * e.life;
        ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.stroke();
      } else if (e.type === 'confetti') {
        e.particles.forEach(p => {
            if (p.life > 0) {
              ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
              ctx.fillRect(e.x + p.x, e.y + p.y, p.w, p.h);
            }
        });
      } else if (e.type === 'explosion') {
        const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, 200 * (1 - e.life));
        grad.addColorStop(0, 'rgba(255, 150, 50, 0.8)');
        grad.addColorStop(1, 'rgba(255, 50, 0, 0)');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      ctx.globalAlpha = 1;
    });
  }

  function mainLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (screenShake.duration > 0) {
        ctx.save();
        ctx.translate((Math.random() - 0.5) * screenShake.magnitude, (Math.random() - 0.5) * screenShake.magnitude);
        screenShake.duration--;
    }

    if (gameState === 'playing') updateSprites();
    updateEffects();
    drawSprites(); drawEffects();
    
    if (screenShake.duration >= 0) ctx.restore();
    requestAnimationFrame(mainLoop);
  }

  /*
    ============================================
    INITIALIZATION
    ============================================
  */
  
  function init() {
    resizeCanvas();
    setupTTS();
    window.addEventListener('resize', resizeCanvas);
    canvas.addEventListener('pointerdown', e => {
        handlePointerDown(e);
    });
    replayBtn.addEventListener('click', () => {
        if (gameState === 'playing') {
            speak(targetLetter === 'B' ? 'Bee' : 'Dee');
        }
    });
    startIntro();
    requestAnimationFrame(mainLoop);
  }

  init();

})();
</script>
</body>
</html>
