<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Sight Words Quiz Deluxe - Mini-Games Edition</title>
  <!-- Google Font + Animate.css -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.fog.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.waves.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.birds.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.cells.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.clouds.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.dots.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.rings.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.halo.min.js"></script>
  <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/progressbar.js/1.1.0/progressbar.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
  <style>
    :root {
      --brand: #26c6da;
      --brand-light: #80deea;
      --brand-dark: #00acc1;
      --bg: #f4f6f8; 
      --fg: #333;
      --btn-bg: #fff;
      --btn-border: #ddd;
      --btn-radius: 16px;
      --transition: 0.2s ease-in-out;
      --correct-bg: #a5d6a7;
      --incorrect-bg: #ef9a9a;
      --selected-border-color: #007bff; /* Blue for selection */
      --shadow-color: rgba(0,0,0,0.1);
    }
    *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;overflow:hidden;font-family:'Poppins',sans-serif;color:var(--fg);
      -webkit-tap-highlight-color:transparent;touch-action:manipulation;
      /* Added styles to prevent text selection and callouts */
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none;    /* Firefox */
      -ms-user-select: none;     /* IE10+/Edge */
      user-select: none;         /* Standard */
      -webkit-touch-callout: none; /* Disable callout menu on iOS */
    }
    body { background-color: var(--bg); }
    #confetti-canvas{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1000}
    
    .top-bar { position: fixed; top: 0; left: 0; width: 100%; height: 70px; display: flex; align-items: center; justify-content: space-between; padding: 0 16px; z-index: 50; }
    #score{ font-size: 1.1rem;font-weight:600; background-color: rgba(255,255,255,0.7); padding: 8px 12px; border-radius: 8px; box-shadow: 0 2px 4px var(--shadow-color); }
    #timer-wrapper { position: absolute; left: 50%; transform: translateX(-50%); width: 60px; height: 60px; }
    #circular-timer { width: 100%; height: 100%; }

    #quiz-container{ display:flex;justify-content:center;align-items:center; min-height: 30vh; padding:1rem; margin-top: 70px; height: calc(100vh - 70px - 70px); }
    #listen-pick-word-area { display: flex; justify-content: center; align-items: center; width: 100%; }
    #read-pick-sound-area { display: none; flex-direction: column; justify-content: center; align-items: center; width: 100%; gap: 1.5rem; }
    .word-display-box { background: var(--btn-bg); border: 3px solid var(--brand-dark); border-radius: var(--btn-radius); padding: 1.5rem 2rem; font-size: 2.5rem; font-weight: 600; color: var(--fg); min-width: 200px; text-align: center; box-shadow: 0 4px 8px var(--shadow-color); }
    #sound-choices-container { display: flex; justify-content: center; gap: 1rem; }
    
    .choice-btn{ flex:1; min-width: 120px; max-width: 200px; margin:0 .75rem;padding:1.2rem; font-size:1.8rem; font-weight: 600; background:var(--btn-bg);border:2px solid var(--btn-border);border-radius:var(--btn-radius); transition:background var(--transition),transform var(--transition), box-shadow var(--transition), border-color var(--transition); touch-action:manipulation; cursor:pointer; box-shadow: 0 4px 6px var(--shadow-color); }
    .choice-btn:hover { transform: translateY(-3px); box-shadow: 0 6px 10px var(--shadow-color); }
    .choice-btn:active{transform:scale(0.96); box-shadow: 0 2px 4px var(--shadow-color);}
    .choice-btn.correct { background-color: var(--correct-bg) !important; border-color: green !important; }
    .choice-btn.incorrect { background-color: var(--incorrect-bg) !important; border-color: darkred !important; }
    
    .sound-btn { font-size: 2rem !important; padding: 1rem 1.5rem !important; }
    .sound-btn-selected {
        border-color: var(--selected-border-color) !important;
        box-shadow: 0 0 0 3px var(--selected-border-color), 0 4px 6px var(--shadow-color) !important;
    }

    #submit-answer-btn { padding: 0.8rem 2rem; font-size: 1.2rem; font-weight: 600; color: white; background-color: var(--brand); border: none; border-radius: var(--btn-radius); cursor: pointer; transition: background-color var(--transition), transform var(--transition); box-shadow: 0 4px 6px var(--shadow-color); }
    #submit-answer-btn:hover { background-color: var(--brand-dark); transform: translateY(-2px); }
    #submit-answer-btn:active { transform: scale(0.98); }
    #submit-answer-btn:disabled { background-color: #ccc; cursor: not-allowed; box-shadow: none; }

    #controls{ position: fixed; bottom: 0; left: 0; width: 100%; display:flex;justify-content:space-around; align-items:center; padding:0.5rem 1rem; height: 70px; background-color: rgba(255,255,255,0.3); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); z-index: 50; }
    #timer-display{ padding:.6rem 1rem;background:var(--btn-bg);border:2px solid var(--btn-border);border-radius:var(--btn-radius); font-weight:600;cursor:pointer; box-shadow: 0 2px 4px var(--shadow-color); font-size: 0.9rem; }
    #listen-btn, #mode-toggle-btn { font-size:1.5rem; background:none;border:none;cursor:pointer;outline:none; padding: 0.5rem; transition: transform 0.2s; color: var(--brand-dark); font-weight: 600; }
    #mode-toggle-btn { font-size: 0.9rem; padding: 0.6rem 0.8rem; background-color: var(--btn-bg); border: 2px solid var(--btn-border); border-radius: var(--btn-radius); box-shadow: 0 2px 4px var(--shadow-color); }
    #listen-btn:active, #mode-toggle-btn:active {transform: scale(0.9);}
    #timer-select{ position:absolute;bottom: calc(70px + 0.5rem); right:1rem;font-size:1rem;padding:.3rem .5rem;display:none; border-radius: 8px; border: 1px solid var(--btn-border); box-shadow: 0 2px 5px var(--shadow-color); }
    #mascot-container { position: fixed; bottom: 1rem; left: 1rem; width: 100px; height: 100px; z-index: 5; pointer-events: none; }
    #mascot-container lottie-player { width: 100%; height: 100%; }
    .floating-effect { position: fixed; padding: 0.5rem 1rem; color: white; border-radius: 20px; font-weight: bold; font-size: 1.2em; z-index: 1200; pointer-events: none; text-align: center; } /* Increased z-index for mini-games */
    .floating-score { background: rgba(76, 175, 80, 0.9); }
    .floating-message { background: var(--brand); }

    /* Level Selection Styles */
    #level-controls-container {
      position: relative;
      display: flex;
      flex-direction: column;     /* Stack buttons vertically */
      align-items: flex-end;      /* Right-align both buttons */
      gap: 0.2rem;                /* Reduced vertical space between buttons for compactness in top bar */
    }
    #levels-toggle-btn, #toggle-minigames-btn { /* Shared styles for consistency */
        padding: 0.4rem 0.8rem; /* Adjusted padding for smaller buttons */
        font-size: 0.8rem; /* Adjusted font size */
        font-weight: 600; 
        background-color: var(--btn-bg); 
        border: 2px solid var(--btn-border); 
        border-radius: var(--btn-radius); 
        cursor: pointer; 
        box-shadow: 0 2px 4px var(--shadow-color);
        width: 120px; /* Fixed width for buttons */
        text-align: center; 
    }
    #levels-dropdown-menu { 
        display: none; 
        position: absolute; 
        top: calc( (0.4rem * 2 + 0.8rem + 2px * 2) + 0.2rem + (0.4rem * 2 + 0.8rem + 2px * 2) ); 
        right: 0; 
        background-color: white; 
        border: 1px solid #ccc; 
        border-radius: 8px; 
        box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
        z-index: 100; 
        padding: 0.5rem 0; 
        min-width: 120px; 
    }
    #levels-dropdown-menu.visible { display: block; }
    .level-item { padding: 0.6rem 1rem; cursor: pointer; display: flex; align-items: center; justify-content: space-between; /* user-select: none; REMOVED, handled globally */ font-size:0.8rem; }
    .level-item:hover { background-color: #f0f0f0; }
    .level-item.selected { background-color: var(--brand-light); color: var(--brand-dark); font-weight: 600; }
    .level-item .long-press-indicator { font-size: 0.7em; color: #777; margin-left: 8px; }
    .level-item.selected .long-press-indicator { color: var(--brand-dark); }


    /* Word Selection Modal Styles */
    #word-selection-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 1000; justify-content: center; align-items: center; padding: 1rem; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
    #word-selection-modal.visible { display: flex; }
    .modal-content { background-color: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); width: 90%; max-width: 600px; max-height: 90vh; display: flex; flex-direction: column; }
    #modal-level-title { margin-top: 0; margin-bottom: 1rem; text-align: center; color: var(--brand-dark); }
    #modal-word-list { overflow-y: auto; flex-grow: 1; border: 1px solid #eee; border-radius: 8px; padding: 0.5rem; margin-bottom: 1rem; display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem; }
    .modal-word-item { display: flex; align-items: center; padding: 0.5rem; border-radius: 6px; background-color: #f9f9f9; cursor: pointer; transition: background-color 0.2s; }
    .modal-word-item:hover { background-color: #e9e9e9; }
    .modal-word-item input[type="checkbox"] { margin-right: 0.75rem; width: 18px; height: 18px; accent-color: var(--brand); }
    .modal-word-item label { flex-grow: 1; /* user-select: none; REMOVED, handled globally */ }
    .modal-actions { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 0.5rem; padding-top: 1rem; border-top: 1px solid #eee; }
    .modal-actions button { padding: 0.6rem 1rem; font-size: 0.9rem; border-radius: 8px; border: none; cursor: pointer; background-color: var(--brand); color: white; transition: background-color 0.2s; }
    .modal-actions button:hover { background-color: var(--brand-dark); }
    .modal-actions button#modal-close-btn { background-color: #aaa; }
    .modal-actions button#modal-close-btn:hover { background-color: #888; }
    .hidden { display: none !important; }

    /* Mini-Game Styles */
    #toggle-minigames-btn.active-minigame-toggle { 
        background-color: var(--brand-light);
        color: var(--brand-dark);
        border-color: var(--brand-dark);
    }

    #minigame-area {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(100, 150, 220, 0.9); 
        z-index: 900; 
        display: none;
        justify-content: center;
        align-items: center;
        flex-direction: column; 
        overflow: hidden;
        color: white;
        font-size: 1.5rem;
    }
    #minigame-area.active {
        display: flex;
    }
    .minigame-info-bar {
        position: absolute;
        top: 20px;
        left: 20px;
        right: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background-color: rgba(0,0,0,0.2);
        border-radius: 8px;
        font-size: 1.2rem;
    }
    .minigame-score { font-weight: bold; }
    .minigame-timer-bar-container {
        height: 20px;
        flex-grow: 1;
        margin: 0 20px;
        background-color: rgba(255,255,255,0.3);
        border-radius: 10px;
        overflow: hidden;
    }
    .minigame-timer-bar {
        height: 100%;
        width: 100%;
        background-color: var(--brand-light);
        transition: width 0.2s linear; 
    }
    .minigame-timer-text { font-weight: bold; }

    /* Balloon Pop Specific */
    .balloon {
        width: 60px;
        height: 80px;
        border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; 
        position: absolute;
        cursor: pointer;
        /* user-select: none; REMOVED, handled globally */
        display: flex;
        justify-content: center;
        align-items: flex-end; 
        padding-bottom: 5px; 
    }
    .balloon::after { 
        content: '';
        position: absolute;
        bottom: -15px; 
        left: 50%;
        transform: translateX(-50%);
        width: 2px;
        height: 20px; 
        background-color: rgba(255,255,255,0.7);
    }
    .balloon-rising {
        animation: riseAnimation 5s linear forwards;
    }
    @keyframes riseAnimation {
        from { transform: translateY(0); }
        to { transform: translateY(-110vh); } 
    }

    /* Bounce Party Specific */
    .bounce-ball {
        width: 50px;
        height: 50px;
        background-color: var(--brand);
        border-radius: 50%;
        position: absolute; 
        cursor: pointer;
        box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }
    .animate__fadeOutCustom { animation-duration: 0.3s; }
    .animate__fadeInCustom { animation-duration: 0.3s; }

  </style>
</head>
<body>
<canvas id="confetti-canvas"></canvas>

  <div class="top-bar">
    <div id="score">Score: <span id="score-val">0</span></div>
    <div id="timer-wrapper"><div id="circular-timer"></div></div>
    <div id="level-controls-container">
        <button id="toggle-minigames-btn">Mini-Games: Off</button>
        <button id="levels-toggle-btn">Levels</button>
        <div id="levels-dropdown-menu">
            <!-- Level items will be populated by JS -->
        </div>
    </div>
  </div>

  <div id="word-selection-modal">
    <div class="modal-content">
        <h2 id="modal-level-title">Customize Words</h2>
        <div id="modal-word-list"></div>
        <div class="modal-actions">
            <button id="modal-save-btn">Save & Use</button>
            <button id="modal-select-all-btn">Select All</button>
            <button id="modal-deselect-all-btn">Deselect All</button>
            <button id="modal-close-btn">Close</button>
        </div>
    </div>
  </div>

  <div id="quiz-container" class="animate__animated">
    <div id="listen-pick-word-area">
      <button id="choice0" class="choice-btn"></button>
      <button id="choice1" class="choice-btn"></button>
    </div>
    <div id="read-pick-sound-area">
      <div id="word-to-read" class="word-display-box"></div>
      <div id="sound-choices-container">
        <button id="soundChoice0" class="choice-btn sound-btn">üîä</button>
        <button id="soundChoice1" class="choice-btn sound-btn">üîä</button>
      </div>
      <button id="submit-answer-btn" disabled>Submit Answer</button>
    </div>
  </div>

  <div id="minigame-area">
      <!-- Mini-game content will be injected here -->
  </div>

  <div id="controls"> <div id="timer-display">10s ‚è±Ô∏è</div> <button id="mode-toggle-btn">Mode: Listen</button> <button id="listen-btn">üîä</button> </div>
  <select id="timer-select"></select>
  <div id="mascot-container"> <lottie-player src="https://lottie.host/449f9829-8f92-4a63-85a2-def249781a91/p021aHdt2x.json" background="transparent" speed="1" loop autoplay></lottie-player> </div>
  
  <script>
    // --- WEB AUDIO API (condensed - same as before) ---
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)(); if (audioCtx) { window.addEventListener('pointerdown', () => { if (audioCtx.state === 'suspended') audioCtx.resume(); }, { once: true }); } function playOsc({ type='sine', freq=440, dur=0.3, modFreq, modIndex, vol=1 }) { if (!audioCtx) return; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime); if (modFreq && modIndex) { const mod = audioCtx.createOscillator(); const mGain = audioCtx.createGain(); mod.frequency.setValueAtTime(modFreq, audioCtx.currentTime); mGain.gain.setValueAtTime(modIndex, audioCtx.currentTime); mod.connect(mGain).connect(osc.frequency); mod.start(audioCtx.currentTime); mod.stop(audioCtx.currentTime + dur); } osc.connect(gain); gain.connect(audioCtx.destination); gain.gain.setValueAtTime(vol, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur); osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + dur); } function playBell() { if (!audioCtx) return; playOsc({ type:'sine', freq:660, dur:0.3, vol: 0.6 }); setTimeout(() => playOsc({ type:'sine', freq:880, dur:0.3, vol: 0.6 }), 120); } function playBuzz() { if (!audioCtx) return; playOsc({ type:'square', freq:150, dur:0.4, vol: 0.4 }); }
    
    const pronunciationMap = { "I": "I." };

    // --- VANTA.JS DYNAMIC BACKGROUNDS (condensed - same as before) ---
    let vantaEffect = null; const vantaElement = document.body; let vantaBackgroundKeys = []; let currentBackgroundKey = null; const baseGlobalParams = { mouseControls: true, touchControls: true, gyroControls: false, minHeight: 200.00, minWidth: 200.00, scale: 1.00, scaleMobile: 1.00, }; const effectConfigurations = { "FOG_Soft_Blue": { effect: "FOG", params: { highlightColor: 0x80deea, midtoneColor: 0x26c6da, lowlightColor: 0x00acc1, baseColor: 0xf4f6f8, blurFactor: 0.6, zoom: 1.2, speed: 1.0 }}, "WAVES_Ocean": { effect: "WAVES", params: { color: 0x005577, shininess: 30, waveHeight: 15, waveSpeed: 0.8, zoom: 1.0 }}, "BIRDS_Day_Sky": { effect: "BIRDS", params: { backgroundColor: 0x87ceeb, color1: 0x444444, color2: 0x666666, birdSize: 1.0, wingSpan: 20.00, speedLimit: 3.00, separation: 20.00, alignment: 20.00, cohesion: 20.00, quantity: 4 }}, "NET_Cyber_Grid": { effect: "NET", params: { color: 0x00ffff, backgroundColor: 0x000022, points: 10.00, maxDistance: 20.00, spacing: 15.00, showDots: true }}, "CELLS_Bio_Blue": { effect: "CELLS", params: { color1: 0x2196f3, color2: 0x90caf9, size: 3.0, speed: 1.0 }}, "CLOUDS_Sunny_Day": { effect: "CLOUDS", params: { skyColor: 0x68b8d7, cloudColor: 0xadc1de, cloudShadowColor: 0x183550, sunColor: 0xff9919, sunGlareColor: 0xff6633, sunlightColor: 0xff9933, speed: 1.0 }}, "DOTS_Starfield": { effect: "DOTS", params: { color: 0xffffff, color2: 0xdddddd, backgroundColor: 0x000011, size: 3.00, spacing: 30.00, showLines: false }}, "RINGS_Golden_Aura": { effect: "RINGS", params: { backgroundColor: 0x110022, color: 0xffd700, strength: 2.00 }}, "HALO_Gentle_Sun": { effect: "HALO", params: { baseColor: 0xffe082, backgroundColor: 0xfff8e1, amplitudeFactor: 0.5, size: 1.0 }}, "FOG_Mystic_Purple": { effect: "FOG", params: { highlightColor: 0xff00ff, midtoneColor: 0xaa00aa, lowlightColor: 0x550055, baseColor: 0x300030, blurFactor: 0.7, zoom: 1.0, speed: 0.8 }}, "WAVES_Lava": { effect: "WAVES", params: { color: 0xff3300, shininess: 10, waveHeight: 25, waveSpeed: 0.4, zoom: 0.75 }}, "BIRDS_Sunset": { effect: "BIRDS", params: { backgroundColor: 0xffa07a, color1: 0x5d4037, color2: 0x000000, birdSize: 1.2, wingSpan: 25.00, quantity: 3, speedLimit: 2.00 }}, "NET_Golden_Web": { effect: "NET", params: { color: 0xffd700, backgroundColor: 0x301934, points: 8.00, maxDistance: 25.00, spacing: 20.00, showDots: true }}, "CELLS_Pulsing_Red": { effect: "CELLS", params: { color1: 0xf44336, color2: 0xffcdd2, size: 4.5, speed: 0.5 }}, "CLOUDS_Evening_Sky": { effect: "CLOUDS", params: { skyColor: 0x334d5c, cloudColor: 0x8e8e8e, cloudShadowColor: 0x2e2e2e, sunColor: 0xf57c00, sunGlareColor: 0xffb74d, sunlightColor: 0xffa726, speed: 0.6 }}, "DOTS_Colorful_Grid": { effect: "DOTS", params: { color: 0xff00ff, color2: 0x00ff00, backgroundColor: 0x222222, size: 5.00, spacing: 25.00, showLines: true }}, "RINGS_Blue_Energy": { effect: "RINGS", params: { backgroundColor: 0x001020, color: 0x00aaff, strength: 3.50 }}, "HALO_Deep_Space": { effect: "HALO", params: { baseColor: 0x7e57c2, backgroundColor: 0x1a001a, amplitudeFactor: 1.5, size: 1.2, xOffset: 0.2, yOffset: 0.1 }} }; function applyVantaEffect(configKey) { if (vantaEffect) { try { vantaEffect.destroy(); } catch (e) { console.error("Err destroy vanta:", e); } vantaEffect = null; } const config = effectConfigurations[configKey]; if (!config || typeof VANTA === 'undefined' || typeof VANTA[config.effect] !== 'function') { console.error(`Vanta effect ${configKey} error.`); return; } const finalParams = { el: vantaElement, ...baseGlobalParams, ...config.params }; try { vantaEffect = VANTA[config.effect](finalParams); currentBackgroundKey = configKey; } catch (error) { console.error(`Err init Vanta '${config.effect}':`, error); vantaEffect = null; } }
    
    // --- WORD DATA (same as before) ---
    const allLevelWords = { A: ["a","all","am","and","away","be","big","blue","but","can","come", "did","down","find","for","funny","go","good","he","help","here","I", "in","is","it","like","little","look","make","me","my","no","not", "on","one","play","ran","red","run","said","see","so","that","the", "three","to","two","up","was","we","what","where","yellow","yes","you"], B: ["after","again","any","are","as","at","ate","black","brown","by","came","could","do","eat","every","four","from","get","give","going","had","have","her","him","how","into","let","must","new","now","of","our","out","please","pretty","ride","round","saw","say","she","some","soon","thank","there","they","this","too","under","want","well","went","white","who","will","with"], C: ["an","ask","been","best","buy","cold","does","don't","first","five","fly","found","gave","goes","green","has","his","its","jump","just","know","live","made","many","may","off","old","once","open","or","over","own","pull","put","read","right","sit","sleep","stop","take","tell","them","then","these","think","those","use","very","walk","warm","wash","were","when","why","your"], D: ["about","always","around","because","before","better","both","bring","call","carry","clean","cut","done","draw","drink","eight","fall","far","fast","full","got","grow","hold","hot","hurt","if","keep","kind","laugh","light","long","much","myself","never","only","pick","seven","shall","show","sing","six","small","start","ten","their","today","together","try","upon","us","which","wish","work","would","write"] };
    let words = []; 

    // --- UI REFERENCES (same as before + new ones) ---
    const wordChoiceBtns = [document.getElementById('choice0'), document.getElementById('choice1')];
    const scoreVal   = document.getElementById('score-val');
    const timerDisp  = document.getElementById('timer-display');
    const timerSel   = document.getElementById('timer-select');
    const listenBtn  = document.getElementById('listen-btn');
    const quizCont   = document.getElementById('quiz-container');
    const controlsBar = document.getElementById('controls'); 
    const modeToggleBtn = document.getElementById('mode-toggle-btn');
    const listenPickWordArea = document.getElementById('listen-pick-word-area');
    const readPickSoundArea = document.getElementById('read-pick-sound-area');
    const wordToReadDisplay = document.getElementById('word-to-read');
    const soundChoiceBtns = [document.getElementById('soundChoice0'), document.getElementById('soundChoice1')];
    const submitAnswerBtn = document.getElementById('submit-answer-btn');
    const confettiCanvas = document.getElementById('confetti-canvas');
    const myConfetti = confetti.create(confettiCanvas, { resize: true, useWorker: true });
    const levelsToggleBtn = document.getElementById('levels-toggle-btn');
    const levelsDropdownMenu = document.getElementById('levels-dropdown-menu');
    const wordSelectionModal = document.getElementById('word-selection-modal');
    const modalLevelTitle = document.getElementById('modal-level-title');
    const modalWordList = document.getElementById('modal-word-list');
    const modalSaveBtn = document.getElementById('modal-save-btn');
    const modalSelectAllBtn = document.getElementById('modal-select-all-btn');
    const modalDeselectAllBtn = document.getElementById('modal-deselect-all-btn');
    const modalCloseBtn = document.getElementById('modal-close-btn');
    
    const miniGameArea = document.getElementById('minigame-area');
    const toggleMiniGamesBtn = document.getElementById('toggle-minigames-btn');


    // --- GAME STATE (same as before + new ones) ---
    let circleTimerInstance;
    let questionTimeoutId; 
    let questionAnsweredThisTurn = false;
    let score = 0;
    let timeLimit = 10; 
    let currentCorrectWord = "";
    let currentStreak = 0;
    const streakThresholds = {3: "Streak x3!", 5: "Super Streak x5!", 10: "AMAZING x10!"};
    let currentGameMode = localStorage.getItem('sightWordsGameMode') || 'listenAndPickWord';
    let selectedSoundButton = null;
    let selectedLevels = [];
    let currentEditingLevelKey = null; 
    let longPressTimer = null;
    let isLongPress = false;

    let miniGamesEnabled = localStorage.getItem('miniGamesEnabled') === 'true';
    let isMiniGameActive = false;
    let availableMiniGames = [];
    let currentMiniGameIdx = 0;


    // ---- INITIALIZATION ----
    document.addEventListener('DOMContentLoaded', () => {
      vantaBackgroundKeys = Object.keys(effectConfigurations);
      if (vantaBackgroundKeys.length > 0 && typeof THREE !== 'undefined' && typeof VANTA !== 'undefined') {
        applyVantaEffect(vantaBackgroundKeys[0]);
      }
      
      initLevelManagement(); 
      initMiniGameSystem(); 
      updateModeUI();
      initCircularTimer();
      
      for(let i=0;i<=30;i++){ let o = document.createElement('option'); o.value = i; o.textContent = i+'s' + (i === 0 ? ' (Untimed)' : ''); timerSel.append(o); }
      timerSel.value = timeLimit; 
      timerDisp.textContent = timeLimit > 0 ? timeLimit+'s ‚è±Ô∏è' : 'Untimed ‚è±Ô∏è';

      // Prevent context menu (often triggered by long-press on touch or right-click)
      document.addEventListener('contextmenu', function(event) {
        event.preventDefault();
      });
    });

    // --- Speak helper (MODIFIED with pronunciationMap) ---
    function speak(txt, rate = 0.9, pitch = 1.1){ if('speechSynthesis' in window){ speechSynthesis.cancel(); let textToSpeak = pronunciationMap[txt] || String(txt); let u = new SpeechSynthesisUtterance(textToSpeak); u.rate = rate; u.pitch = pitch; speechSynthesis.speak(u); } }
    function getRandomColor() { const r = Math.floor(Math.random() * 200); const g = Math.floor(Math.random() * 200); const b = Math.floor(Math.random() * 200); return `rgb(${r},${g},${b})`; }
           
    // --- MINI-GAME DEFINITIONS ---
    // --- (Keep your existing helper functions like speak, playBell, myConfetti) ---

const CatchTheStarGame = {
    name: "Catch the Star",
    score: 0,
    gameTimerId: null,        // For overall game duration
    starIntervalId: null,     // For spawning stars
    timerIntervalId: null,    // For updating the visual timer bar
    animationFrameId: null,   // For the game's main loop (collision detection)
    container: null,
    onCompleteCallback: null,
    duration: 20000,          // 20 seconds
    starsOnScreen: [],        // Array of starData objects { element, removeTimeoutId }
    elements: {},             // To store UI elements like scoreDisplay, timerBar

    // --- New properties for Hoop mechanic ---
    hoopElement: null,
    isHoopingActive: false,    // True when pointer is down
    hoopRadius: 50,            // Radius of the hoop in pixels
    starVisualRadius: 20,      // Approximate visual radius of a star for collision
    hoopPosition: { x: 0, y: 0 }, // Center of the hoop, relative to the container

    // Bound event handlers for easy add/remove
    boundOnPointerDown: null,
    boundOnPointerMove: null,
    boundOnPointerUp: null,
    boundGameLoop: null,

    start: function(containerElement, onComplete) {
        this.container = containerElement;
        this.onCompleteCallback = onComplete;
        this.score = 0;
        this.starsOnScreen = [];
        this.container.innerHTML = ''; // Clear previous game content

        speak("Catch the stars in your hoop!");

        // Setup UI (score, timer bar - same as before)
        const infoBar = document.createElement('div');
        infoBar.className = 'minigame-info-bar';
        this.elements.scoreDisplay = document.createElement('div');
        this.elements.scoreDisplay.className = 'minigame-score';
        infoBar.appendChild(this.elements.scoreDisplay);
        this.updateScoreDisplay();

        const timerContainer = document.createElement('div');
        timerContainer.className = 'minigame-timer-bar-container';
        this.elements.timerBar = document.createElement('div');
        this.elements.timerBar.className = 'minigame-timer-bar';
        timerContainer.appendChild(this.elements.timerBar);
        infoBar.appendChild(timerContainer);
        this.container.appendChild(infoBar);

        let timeLeft = this.duration;
        this.elements.timerBar.style.width = '100%';
        this.timerIntervalId = setInterval(() => {
            timeLeft -= 100;
            const progress = Math.max(0, (timeLeft / this.duration) * 100);
            this.elements.timerBar.style.width = `${progress}%`;
            if (timeLeft <= 0) clearInterval(this.timerIntervalId);
        }, 100);

        // --- Hoop Setup ---
        this.hoopElement = document.createElement('div');
        this.hoopElement.style.position = 'absolute';
        this.hoopElement.style.width = `${this.hoopRadius * 2}px`;
        this.hoopElement.style.height = `${this.hoopRadius * 2}px`;
        this.hoopElement.style.border = '3px dashed white';
        this.hoopElement.style.borderRadius = '50%';
        this.hoopElement.style.boxSizing = 'border-box';
        this.hoopElement.style.display = 'none'; // Initially hidden
        this.hoopElement.style.pointerEvents = 'none'; // Hoop itself should not catch pointer events
        this.container.appendChild(this.hoopElement);

        // Bind event handlers
        this.boundOnPointerDown = this.onPointerDown.bind(this);
        this.boundOnPointerMove = this.onPointerMove.bind(this);
        this.boundOnPointerUp = this.onPointerUp.bind(this);
        this.boundGameLoop = this.gameLoop.bind(this);

        // Add event listeners to the game container
        this.container.addEventListener('pointerdown', this.boundOnPointerDown);
        // We add move/up to window to catch events even if pointer leaves container
        window.addEventListener('pointermove', this.boundOnPointerMove);
        window.addEventListener('pointerup', this.boundOnPointerUp);
        window.addEventListener('pointercancel', this.boundOnPointerUp); // Handle cancellations

        this.starIntervalId = setInterval(() => this.spawnStar(), 800); // Spawn stars
        this.gameTimerId = setTimeout(() => this.endGame(), this.duration); // End game after duration

        this.animationFrameId = requestAnimationFrame(this.boundGameLoop); // Start the game loop
    },

    onPointerDown: function(event) {
        // Only activate if the event is within the game container
        if (event.target !== this.container && !this.container.contains(event.target)) {
             // If pointerdown is on a star or other element *inside* the container,
             // we still want to activate the hoop if the container itself is the event handler target.
             // However, if the event.target is something entirely outside the container, ignore.
             let el = event.target;
             let isInsideContainer = false;
             while(el) {
                if (el === this.container) {
                    isInsideContainer = true;
                    break;
                }
                el = el.parentElement;
             }
             if(!isInsideContainer) return;
        }
        event.preventDefault(); // Prevent default browser actions like text selection or scrolling
        this.isHoopingActive = true;
        this.updateHoopDisplay(event);
        this.hoopElement.style.display = 'block';
    },

    onPointerMove: function(event) {
        if (this.isHoopingActive) {
            event.preventDefault();
            this.updateHoopDisplay(event);
        }
    },

    onPointerUp: function(event) {
        if (this.isHoopingActive) {
            // event.preventDefault(); // Not always needed for up, but can be good
            this.isHoopingActive = false;
            this.hoopElement.style.display = 'none';
        }
    },

    updateHoopDisplay: function(event) {
        if (!this.container) return;
        const rect = this.container.getBoundingClientRect();
        // Calculate pointer position relative to the container
        this.hoopPosition.x = event.clientX - rect.left;
        this.hoopPosition.y = event.clientY - rect.top;

        // Position the hoop so its center is at the pointer
        this.hoopElement.style.left = `${this.hoopPosition.x - this.hoopRadius}px`;
        this.hoopElement.style.top = `${this.hoopPosition.y - this.hoopRadius}px`;
    },

    gameLoop: function() {
        if (this.isHoopingActive) {
            this.checkHoopCollisions();
        }
        this.animationFrameId = requestAnimationFrame(this.boundGameLoop);
    },

    checkHoopCollisions: function() {
        if (!this.isHoopingActive || this.starsOnScreen.length === 0) return;

        // Iterate backwards because we might be removing items from the array
        for (let i = this.starsOnScreen.length - 1; i >= 0; i--) {
            const starData = this.starsOnScreen[i];
            const starElement = starData.element;

            if (!starElement.parentNode) { // Star already removed (e.g., by timeout)
                this.starsOnScreen.splice(i, 1);
                continue;
            }

            const starCenterX = starElement.offsetLeft + starElement.offsetWidth / 2;
            const starCenterY = starElement.offsetTop + starElement.offsetHeight / 2;

            const dx = this.hoopPosition.x - starCenterX;
            const dy = this.hoopPosition.y - starCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Collision if distance is less than sum of hoop radius and star's visual radius
            if (distance < this.hoopRadius + this.starVisualRadius) {
                this._processStarCatch(starData, i); // Pass index for efficient removal
            }
        }
    },

    spawnStar: function() {
        if (!this.container || this.starsOnScreen.length > 12) return; // Max 12 stars
        const star = document.createElement('div');
        star.style.position = 'absolute';
        star.style.width = '40px'; // Star visual size
        star.style.height = '40px';
        star.style.left = `${Math.random() * (this.container.clientWidth - 40)}px`;
        star.style.top = `-40px`; // Start above screen
        star.style.fontSize = '2.2rem';
        star.style.userSelect = 'none'; // Global CSS should handle this too
        // star.style.cursor = 'pointer'; // Not clickable directly anymore
        star.style.transition = 'top 1.9s linear, transform 0.3s ease-out'; // Added transform for pop
        star.textContent = '‚≠ê';
        
        this.container.appendChild(star);

        const starData = {
            element: star,
            removeTimeoutId: null 
        };
        this.starsOnScreen.push(starData);

        // Trigger CSS animation to move down
        setTimeout(() => {
            if (star.parentNode) { // Check if still in DOM
                 star.style.top = `${this.container.clientHeight}px`; // Fall to bottom
            }
        }, 30); 

        // Set timeout to remove star if not caught and falls off screen
        starData.removeTimeoutId = setTimeout(() => {
            const index = this.starsOnScreen.indexOf(starData);
            if (index !== -1) { // If still in the array (i.e., not caught)
                if (star.parentNode) {
                    star.remove();
                }
                this.starsOnScreen.splice(index, 1);
            }
        }, 1900); // Matches transition duration
    },

    _processStarCatch: function(starData, starArrayIndex) {
        const starElement = starData.element;

        // Clear the timeout that would remove it if it fell off screen
        clearTimeout(starData.removeTimeoutId);

        playBell(); // Assume playBell is defined globally
        const rect = starElement.getBoundingClientRect(); // For confetti origin
        const x = (rect.left + rect.right) / 2 / window.innerWidth;
        const y = (rect.top + rect.bottom) / 2 / window.innerHeight;
        myConfetti({ particleCount: 25, spread: 45, origin: { x: x, y: y }, scalar: 0.6 }); // Assume myConfetti is global

        this.score++;
        speak(this.score, 1.2, 1.3); // Assume speak is defined globally
        this.updateScoreDisplay();

        // Visual feedback for caught star (e.g., shrink and fade)
        starElement.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
        starElement.style.transform = 'scale(0.1)';
        starElement.style.opacity = '0';

        // Remove from DOM after animation & from array
        setTimeout(() => {
            if (starElement.parentNode) {
                starElement.remove();
            }
        }, 300); // Matches animation duration

        // Remove from starsOnScreen array
        if (starArrayIndex !== undefined && starArrayIndex < this.starsOnScreen.length && this.starsOnScreen[starArrayIndex] === starData) {
            this.starsOnScreen.splice(starArrayIndex, 1);
        } else {
            // Fallback if index is not reliable (shouldn't happen with reverse loop)
            const index = this.starsOnScreen.indexOf(starData);
            if (index !== -1) this.starsOnScreen.splice(index, 1);
        }
    },

    updateScoreDisplay: function() {
        if(this.elements.scoreDisplay) this.elements.scoreDisplay.textContent = `Stars: ${this.score}`;
    },

    endGame: function() {
        // Clear intervals and timeouts
        clearInterval(this.starIntervalId);
        this.starIntervalId = null;
        clearInterval(this.timerIntervalId);
        this.timerIntervalId = null;
        clearTimeout(this.gameTimerId);
        this.gameTimerId = null;
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;

        // Remove event listeners
        if (this.container) {
            this.container.removeEventListener('pointerdown', this.boundOnPointerDown);
        }
        window.removeEventListener('pointermove', this.boundOnPointerMove);
        window.removeEventListener('pointerup', this.boundOnPointerUp);
        window.removeEventListener('pointercancel', this.boundOnPointerUp);


        // Clean up remaining stars
        this.starsOnScreen.forEach(starData => {
            clearTimeout(starData.removeTimeoutId);
            if (starData.element.parentNode) {
                starData.element.remove();
            }
        });
        this.starsOnScreen = [];

        // Hide and remove hoop
        if (this.hoopElement && this.hoopElement.parentNode) {
            this.hoopElement.remove();
        }
        this.hoopElement = null;
        this.isHoopingActive = false;

        speak(`Game over! You caught ${this.score} stars!`);
        if(this.onCompleteCallback) this.onCompleteCallback(this.score);
    },

    destroy: function() {
        this.endGame(); // endGame already handles most cleanup
        if (this.container) this.container.innerHTML = ''; // Final clear of container
        this.container = null;
        this.elements = {};
        // console.log(`${this.name} destroyed`);
    }
};
    const BalloonPopGame = {
        name: "Balloon Pop",
        score: 0,
        gameTimerId: null,
        timerIntervalId: null,
        balloonIntervalId: null,
        container: null,
        onCompleteCallback: null,
        duration: 20000, 
        balloonsOnScreen: [],
        elements: {},
        forgivingTapRadius: 60, 
        boundForgivingTapHandler: null,

        start: function(containerElement, onComplete) {
            this.container = containerElement;
            this.onCompleteCallback = onComplete;
            this.score = 0;
            this.balloonsOnScreen = [];
            this.container.innerHTML = ''; 
            speak("Tap as many balloons as you can before time runs out!");
            const infoBar = document.createElement('div');
            infoBar.className = 'minigame-info-bar';
            this.elements.scoreDisplay = document.createElement('div');
            this.elements.scoreDisplay.className = 'minigame-score';
            infoBar.appendChild(this.elements.scoreDisplay);
            this.updateScoreDisplay();
            const timerContainer = document.createElement('div');
            timerContainer.className = 'minigame-timer-bar-container';
            this.elements.timerBar = document.createElement('div');
            this.elements.timerBar.className = 'minigame-timer-bar';
            timerContainer.appendChild(this.elements.timerBar);
            infoBar.appendChild(timerContainer);
            this.container.appendChild(infoBar);
            let timeLeft = this.duration;
            this.elements.timerBar.style.width = '100%';
            this.timerIntervalId = setInterval(() => {
                timeLeft -= 100;
                const progress = Math.max(0, (timeLeft / this.duration) * 100);
                this.elements.timerBar.style.width = `${progress}%`;
                if (timeLeft <= 0) {
                    clearInterval(this.timerIntervalId);
                }
            }, 100);
            this.balloonIntervalId = setInterval(() => this.spawnBalloon(), 700); 
            this.gameTimerId = setTimeout(() => this.endGame(), this.duration);
            this.boundForgivingTapHandler = this._handleForgivingTap.bind(this);
            this.container.addEventListener('click', this.boundForgivingTapHandler);
        },
        _handleForgivingTap: function(event) {
            const containerRect = this.container.getBoundingClientRect();
            const clickX = event.clientX - containerRect.left;
            const clickY = event.clientY - containerRect.top;
            this.balloonsOnScreen.slice().forEach(balloonElement => {
                if (!balloonElement || !balloonElement.parentNode) return; 
                const balloonCenterX = balloonElement.offsetLeft + balloonElement.offsetWidth / 2;
                const balloonCenterY = balloonElement.offsetTop + balloonElement.offsetHeight / 2;
                const distance = Math.sqrt(
                    Math.pow(clickX - balloonCenterX, 2) + 
                    Math.pow(clickY - balloonCenterY, 2)
                );
                if (distance <= this.forgivingTapRadius) {
                    if (event.target !== balloonElement) {
                        this.popBalloon(balloonElement);
                    }
                }
            });
        },
        spawnBalloon: function() {
            if (!this.container || this.balloonsOnScreen.length > 15) return;
            const balloon = document.createElement('div');
            balloon.className = 'balloon';
            balloon.style.backgroundColor = getRandomColor();
            balloon.style.left = `${Math.random() * (this.container.clientWidth - 60)}px`;
            balloon.style.bottom = '-100px'; 
            balloon.addEventListener('click', () => this.popBalloon(balloon), { once: true });
            this.container.appendChild(balloon);
            this.balloonsOnScreen.push(balloon);
            balloon.classList.add('balloon-rising');
            balloon.addEventListener('animationend', () => {
                const index = this.balloonsOnScreen.indexOf(balloon);
                if (index > -1) this.balloonsOnScreen.splice(index, 1);
                if (balloon.parentNode) balloon.remove();
            }, { once: true });
        },
        popBalloon: function(balloonElement) {
            if (!this.balloonsOnScreen.includes(balloonElement)) return; 
            playBell();
            const rect = balloonElement.getBoundingClientRect();
            const x = (rect.left + rect.right) / 2 / window.innerWidth;
            const y = (rect.top + rect.bottom) / 2 / window.innerHeight;
            myConfetti({ particleCount: 30, spread: 50, origin: { x: x, y: y }, scalar: 0.7 });
            this.score++;
            speak(this.score, 1.2, 1.3); 
            this.updateScoreDisplay();
            if (balloonElement.parentNode) balloonElement.remove(); 
            const index = this.balloonsOnScreen.indexOf(balloonElement);
            if (index > -1) this.balloonsOnScreen.splice(index, 1);
        },
        updateScoreDisplay: function() {
            if(this.elements.scoreDisplay) this.elements.scoreDisplay.textContent = `Popped: ${this.score}`;
        },
        endGame: function() {
            clearInterval(this.balloonIntervalId);
            this.balloonIntervalId = null;
            clearInterval(this.timerIntervalId);
            this.timerIntervalId = null;
            clearTimeout(this.gameTimerId); 
            this.gameTimerId = null;
            this.balloonsOnScreen.forEach(b => { if (b.parentNode) b.remove() });
            this.balloonsOnScreen = [];
            speak(`You popped ${this.score} balloons!`);
            if(this.onCompleteCallback) this.onCompleteCallback(this.score);
        },
        destroy: function() {
            clearInterval(this.balloonIntervalId);
            clearInterval(this.timerIntervalId);
            clearTimeout(this.gameTimerId);
            this.balloonsOnScreen.forEach(b => { if (b.parentNode) b.remove() });
            this.balloonsOnScreen = [];
            if (this.boundForgivingTapHandler && this.container) {
                this.container.removeEventListener('click', this.boundForgivingTapHandler);
            }
            this.boundForgivingTapHandler = null;
            if (this.container) this.container.innerHTML = '';
            this.elements = {};
        }
    };
    const BouncePartyGame = {
        name: "Bounce Party",
        score: 0,
        gameTimerId: null, 
        timerDisplayIntervalId: null, 
        container: null,
        onCompleteCallback: null,
        duration: 20000, 
        ballElement: null,
        ballPosY: 0, ballVelY: 0,
        gravity: 0.4,
        bounceFactor: 0.85,
        tapStrength: 12,
        animationFrameId: null,
        elements: {},
        forgivingTapRadius: 70, 
        boundForgivingContainerTapHandler: null,
        boundHandleTap: null, 

        start: function(containerElement, onComplete) {
            this.container = containerElement;
            this.onCompleteCallback = onComplete;
            this.score = 0;
            this.container.innerHTML = '';
            speak("Keep the ball bouncing!");
            const infoBar = document.createElement('div');
            infoBar.className = 'minigame-info-bar';
            this.elements.scoreDisplay = document.createElement('div');
            this.elements.scoreDisplay.className = 'minigame-score';
            infoBar.appendChild(this.elements.scoreDisplay);
            this.updateScoreDisplay();
            this.elements.timerText = document.createElement('div');
            this.elements.timerText.className = 'minigame-timer-text';
            infoBar.appendChild(this.elements.timerText);
            this.container.appendChild(infoBar);
            this.ballElement = document.createElement('div');
            this.ballElement.className = 'bounce-ball';
            this.container.appendChild(this.ballElement);
            this.ballPosY = 50;
            this.ballVelY = 0;
            const ballInitialX = this.container.clientWidth / 2 - this.ballElement.clientWidth / 2;
            this.ballElement.style.left = `${ballInitialX}px`;
            this.ballElement.style.top = `${this.ballPosY}px`;
            this.boundHandleTap = this.handleTap.bind(this); 
            this.ballElement.addEventListener('click', this.boundHandleTap);
            this.boundForgivingContainerTapHandler = this._handleForgivingContainerTap.bind(this);
            this.container.addEventListener('click', this.boundForgivingContainerTapHandler);
            this.gameLoop = this.gameLoop.bind(this); 
            this.animationFrameId = requestAnimationFrame(this.gameLoop);
            let timeLeftSeconds = this.duration / 1000;
            this.elements.timerText.textContent = `Time: ${timeLeftSeconds}s`;
            this.timerDisplayIntervalId = setInterval(() => {
                timeLeftSeconds--;
                this.elements.timerText.textContent = `Time: ${Math.max(0, timeLeftSeconds)}s`;
                if (timeLeftSeconds <= 0) clearInterval(this.timerDisplayIntervalId);
            }, 1000);
            this.gameTimerId = setTimeout(() => this.endGame(), this.duration);
        },
        _handleForgivingContainerTap: function(event) {
            if (!this.ballElement || !this.ballElement.parentNode) return; 
            if (event.target === this.ballElement) {
                return; 
            }
            const containerRect = this.container.getBoundingClientRect();
            const clickX = event.clientX - containerRect.left;
            const clickY = event.clientY - containerRect.top;
            const ballCenterX = this.ballElement.offsetLeft + this.ballElement.offsetWidth / 2;
            const ballCenterY = this.ballElement.offsetTop + this.ballElement.offsetHeight / 2;
            const distance = Math.sqrt(
                Math.pow(clickX - ballCenterX, 2) +
                Math.pow(clickY - ballCenterY, 2)
            );
            if (distance <= this.forgivingTapRadius) {
                this.handleTap(); 
            }
        },
        gameLoop: function() {
            if (!this.ballElement || !this.container) return;
            this.ballVelY += this.gravity;
            this.ballPosY += this.ballVelY;
            const bottomBoundary = this.container.clientHeight - this.ballElement.clientHeight;
            const topBoundary = 0;
            if (this.ballPosY >= bottomBoundary) {
                this.ballPosY = bottomBoundary;
                this.ballVelY *= -this.bounceFactor;
            }
            if (this.ballPosY <= topBoundary) {
                this.ballPosY = topBoundary;
                this.ballVelY *= -this.bounceFactor;
            }
            this.ballElement.style.top = `${this.ballPosY}px`;
            this.animationFrameId = requestAnimationFrame(this.gameLoop);
        },
        handleTap: function() {
            if (!this.ballElement) return;
            this.ballVelY = -this.tapStrength;
            playBell();
            const rect = this.ballElement.getBoundingClientRect();
            const x = (rect.left + rect.right) / 2 / window.innerWidth;
            const y = (rect.top + rect.bottom) / 2 / window.innerHeight;
            myConfetti({ particleCount: 20, spread: 40, origin: { x: x, y: y }, scalar: 0.6 });
            this.score++;
            speak(this.score, 1.2, 1.3);
            this.updateScoreDisplay();
        },
        updateScoreDisplay: function() {
             if(this.elements.scoreDisplay) this.elements.scoreDisplay.textContent = `Bounces: ${this.score}`;
        },
        endGame: function() {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
            clearInterval(this.timerDisplayIntervalId);
            this.timerDisplayIntervalId = null;
            clearTimeout(this.gameTimerId);
            this.gameTimerId = null;
            if (this.ballElement && this.boundHandleTap) {
                this.ballElement.removeEventListener('click', this.boundHandleTap);
            }
            speak(`You bounced the ball ${this.score} times!`);
            if(this.onCompleteCallback) this.onCompleteCallback(this.score);
        },
        destroy: function() {
            cancelAnimationFrame(this.animationFrameId);
            clearInterval(this.timerDisplayIntervalId);
            clearTimeout(this.gameTimerId);
            if (this.ballElement && this.boundHandleTap) {
                this.ballElement.removeEventListener('click', this.boundHandleTap);
            }
            this.boundHandleTap = null;
            if (this.boundForgivingContainerTapHandler && this.container) {
                this.container.removeEventListener('click', this.boundForgivingContainerTapHandler);
            }
            this.boundForgivingContainerTapHandler = null;
            if (this.container) this.container.innerHTML = '';
            this.ballElement = null;
            this.elements = {};
        }
    };
    
    // --- MINI-GAME SYSTEM ---
    function initMiniGameSystem() {
        availableMiniGames.push(CatchTheStarGame, BalloonPopGame, BouncePartyGame); 
        toggleMiniGamesBtn.textContent = `Mini-Games: ${miniGamesEnabled ? 'On' : 'Off'}`;
        if (miniGamesEnabled) {
            toggleMiniGamesBtn.classList.add('active-minigame-toggle');
        }
        toggleMiniGamesBtn.addEventListener('click', () => {
            miniGamesEnabled = !miniGamesEnabled;
            localStorage.setItem('miniGamesEnabled', miniGamesEnabled);
            toggleMiniGamesBtn.textContent = `Mini-Games: ${miniGamesEnabled ? 'On' : 'Off'}`;
            toggleMiniGamesBtn.classList.toggle('active-minigame-toggle', miniGamesEnabled);
        });
    }
    function triggerMiniGame() {
        if (availableMiniGames.length === 0) {
            resumeQuizAfterMiniGame(undefined); 
            return;
        }
        isMiniGameActive = true; 
        miniGameArea.classList.add('active');
        miniGameArea.setAttribute('tabindex', '-1');
        miniGameArea.focus();
        const gameToPlay = availableMiniGames[currentMiniGameIdx];
        currentMiniGameIdx = (currentMiniGameIdx + 1) % availableMiniGames.length;
        gameToPlay.start(miniGameArea, (miniGameScore) => {
            gameToPlay.destroy(); 
            miniGameArea.classList.remove('active');
            resumeQuizAfterMiniGame(miniGameScore); 
        });
    }
    function resumeQuizAfterMiniGame(miniGameScore) {
        isMiniGameActive = false; 
        quizCont.style.display = 'flex'; 
        controlsBar.style.display = 'flex';
        quizCont.classList.add('animate__animated', 'animate__fadeInCustom');
        controlsBar.classList.add('animate__animated', 'animate__fadeInCustom');
        const animationEndHandler = () => {
            quizCont.classList.remove('animate__animated', 'animate__fadeInCustom');
            controlsBar.classList.remove('animate__animated', 'animate__fadeInCustom');
            if (miniGameScore !== undefined) {
                showFloatingMessage(`Mini-Game: ${miniGameScore} points!`, 'var(--brand-light)', 'var(--fg)');
            }
            setTimeout(nextQ, 300); 
        };
        if (typeof gsap !== 'undefined') {
            gsap.fromTo([quizCont, controlsBar], {opacity: 0}, {opacity: 1, duration: 0.3, onComplete: animationEndHandler});
        } else {
             quizCont.addEventListener('animationend', animationEndHandler, { once: true });
             setTimeout(() => { 
                if (quizCont.classList.contains('animate__fadeInCustom')) {
                    animationEndHandler();
                }
            }, 500);
        }
    }

    // --- UI & GAME LOGIC (mostly same as before, with modifications for mini-games) ---
    function updateModeUI() { if (currentGameMode === 'listenAndPickWord') { listenPickWordArea.style.display = 'flex'; readPickSoundArea.style.display = 'none'; modeToggleBtn.textContent = 'Mode: Listen'; listenBtn.innerHTML = 'üîä'; } else { listenPickWordArea.style.display = 'none'; readPickSoundArea.style.display = 'flex'; modeToggleBtn.textContent = 'Mode: Read'; listenBtn.innerHTML = 'üìñ'; if(submitAnswerBtn) submitAnswerBtn.disabled = true; } }
    modeToggleBtn.addEventListener('click', () => { currentGameMode = (currentGameMode === 'listenAndPickWord') ? 'readAndPickSound' : 'listenAndPickWord'; localStorage.setItem('sightWordsGameMode', currentGameMode); updateModeUI(); clearTimeout(questionTimeoutId); resetQuestionState(); setTimeout(nextQ, 100); });
    function resetQuestionState() { questionAnsweredThisTurn = false; selectedSoundButton = null; soundChoiceBtns.forEach(btn => btn.classList.remove('sound-btn-selected', 'correct', 'incorrect')); wordChoiceBtns.forEach(btn => btn.classList.remove('correct', 'incorrect')); if (submitAnswerBtn) submitAnswerBtn.disabled = true; }
    function initCircularTimer() { const timerContainer = document.getElementById('circular-timer'); if (!timerContainer) return; circleTimerInstance = new ProgressBar.Circle(timerContainer, { strokeWidth: 10, easing: 'linear', color: 'var(--brand)', trailColor: 'rgba(224, 224, 224, 0.5)', trailWidth: 10, svgStyle: { width: '100%', height: '100%' }, text: { style: { color: 'var(--fg)', position: 'absolute', left: '50%', top: '50%', padding: 0, margin: 0, transform: { prefix: true, value: 'translate(-50%, -50%)' }, fontSize: '1.4em', fontWeight: '600', }, autoStyleContainer: false }, step: function(state, circle) { if (timeLimit > 0) { const timeLeft = Math.ceil(timeLimit * (1 - circle.value())); circle.setText(timeLeft > 0 ? timeLeft : '0'); if (timeLeft <= timeLimit * 0.3) circle.path.setAttribute('stroke', '#f44336'); else if (timeLeft <= timeLimit * 0.6) circle.path.setAttribute('stroke', '#ff9800'); else circle.path.setAttribute('stroke', 'var(--brand)'); } else { circle.setText('‚àû'); circle.path.setAttribute('stroke', 'var(--brand)'); } } }); }
    function startCountdown(onDoneCallback){ clearTimeout(questionTimeoutId); if(circleTimerInstance){ circleTimerInstance.set(0); circleTimerInstance.setText(timeLimit > 0 ? String(timeLimit) : '‚àû'); circleTimerInstance.path.setAttribute('stroke', 'var(--brand)'); if(timeLimit <= 0) return; circleTimerInstance.animate(1.0, { duration: timeLimit * 1000 }); questionTimeoutId = setTimeout(() => { if (!questionAnsweredThisTurn && !isMiniGameActive) onDoneCallback(); }, timeLimit * 1000); } }
    function nextQ(){ resetQuestionState(); quizCont.classList.remove('animate__fadeInCustom', 'animate__zoomIn'); void quizCont.offsetWidth; quizCont.classList.add('animate__zoomIn'); [...wordChoiceBtns, ...soundChoiceBtns].forEach(btn => btn.style.display = ''); if(submitAnswerBtn) submitAnswerBtn.style.display = ''; wordToReadDisplay.style.display = ''; if (words.length === 0) { wordToReadDisplay.textContent = "No Words!"; showFloatingMessage("Please select levels/words!", "var(--brand-dark)"); listenPickWordArea.style.display = 'none'; readPickSoundArea.style.display = 'flex'; soundChoiceBtns.forEach(btn => btn.style.display = 'none'); if (submitAnswerBtn) submitAnswerBtn.style.display = 'none'; wordChoiceBtns.forEach(btn => btn.style.display = 'none'); clearTimeout(questionTimeoutId); if(circleTimerInstance) circleTimerInstance.set(0); return; } currentCorrectWord = words[Math.floor(Math.random()*words.length)]; let distractorWord; if (words.length > 1) { do { distractorWord = words[Math.floor(Math.random()*words.length)]; } while(distractorWord === currentCorrectWord); } else { distractorWord = currentCorrectWord; } if (currentGameMode === 'listenAndPickWord') { const pair = Math.random() < 0.5 ? [currentCorrectWord, distractorWord] : [distractorWord, currentCorrectWord]; wordChoiceBtns.forEach((b,i)=>{ b.textContent = pair[i]; b.disabled = false; b.className = 'choice-btn'; }); speak(currentCorrectWord); } else { wordToReadDisplay.textContent = currentCorrectWord; const soundWords = Math.random() < 0.5 ? [currentCorrectWord, distractorWord] : [distractorWord, currentCorrectWord]; soundChoiceBtns.forEach((btn, i) => { btn.dataset.wordToSpeak = soundWords[i]; btn.disabled = false; btn.className = 'choice-btn sound-btn'; }); if(submitAnswerBtn) submitAnswerBtn.disabled = true; } startCountdown(()=>{ if (questionAnsweredThisTurn || isMiniGameActive) return; questionAnsweredThisTurn = true; disableAllChoiceButtons(); playBuzz(); showFloatingMessage("Time's Up!", '#ffcdd2', '#333'); currentStreak = 0; setTimeout(nextQ,1200); }); }
    function disableAllChoiceButtons() { wordChoiceBtns.forEach(b => b.disabled = true); soundChoiceBtns.forEach(b => b.disabled = true); if (submitAnswerBtn) submitAnswerBtn.disabled = true; }
    function handleAnswer(isCorrect, targetButtonElement) {
        if (questionAnsweredThisTurn || isMiniGameActive) return; 
        questionAnsweredThisTurn = true;
        clearTimeout(questionTimeoutId); 
        disableAllChoiceButtons();
        if(isCorrect){
          playBell();
          scoreVal.textContent = ++score;
          if (score > 0 && score % 10 === 0 && vantaBackgroundKeys.length > 0) { const bgIndex = (score / 10) % vantaBackgroundKeys.length; if (vantaBackgroundKeys[bgIndex] !== currentBackgroundKey) applyVantaEffect(vantaBackgroundKeys[bgIndex]); }
          targetButtonElement.classList.add('correct');
          myConfetti({ particleCount:80, spread:100, origin: { y: 0.6 } });
          showFloatingScore("+1 Awesome!", targetButtonElement);
          currentStreak++;
          if (streakThresholds[currentStreak]) { setTimeout(() => { playBell(); showFloatingMessage(streakThresholds[currentStreak], 'gold', '#333'); myConfetti({ particleCount: 150, spread: 180, startVelocity: 45, origin: { y: 0.5 }}); }, 300); }
        } else {
          playBuzz(); 
          targetButtonElement.classList.add('incorrect');
          if (currentGameMode === 'listenAndPickWord') { wordChoiceBtns.find(b => b.textContent === currentCorrectWord)?.classList.add('correct'); } 
          else { soundChoiceBtns.find(b => b.dataset.wordToSpeak === currentCorrectWord)?.classList.add('correct'); }
          showFloatingScore("Oops!", targetButtonElement, true);
          currentStreak = 0; 
        }
        targetButtonElement.classList.add('animate__animated', isCorrect ? 'animate__pulse' : 'animate__shakeX');
        const isMiniGameDue = isCorrect && miniGamesEnabled && score > 0 && score % 10 === 0;
        targetButtonElement.addEventListener('animationend', () => {
            targetButtonElement.classList.remove('animate__animated', 'animate__pulse', 'animate__shakeX');
            if (targetButtonElement.classList.contains('sound-btn')) {
                 targetButtonElement.classList.remove('sound-btn-selected');
            }
            soundChoiceBtns.forEach(btn => btn.classList.remove('sound-btn-selected'));
            if (isMiniGameDue) { 
                quizCont.style.opacity = 1; 
                controlsBar.style.opacity = 1;
                const fadeOutHandler = () => {
                    quizCont.style.display = 'none';
                    controlsBar.style.display = 'none';
                    triggerMiniGame(); 
                };
                if (typeof gsap !== 'undefined') {
                    gsap.to([quizCont, controlsBar], {opacity: 0, duration: 0.3, onComplete: fadeOutHandler});
                } else {
                    quizCont.classList.add('animate__animated', 'animate__fadeOutCustom');
                    controlsBar.classList.add('animate__animated', 'animate__fadeOutCustom');
                    quizCont.addEventListener('animationend', function tempFadeOutListener() {
                        quizCont.classList.remove('animate__animated', 'animate__fadeOutCustom');
                        controlsBar.classList.remove('animate__animated', 'animate__fadeOutCustom');
                        fadeOutHandler();
                        quizCont.removeEventListener('animationend', tempFadeOutListener);
                    }, { once: true });
                     setTimeout(() => { 
                        if (quizCont.classList.contains('animate__fadeOutCustom')) {
                            fadeOutHandler();
                        }
                    }, 400);
                }
            } else {
                setTimeout(nextQ, 100); 
            }
        }, { once: true });
    }
    wordChoiceBtns.forEach(btn=>{ btn.addEventListener('click',()=>{ if (questionAnsweredThisTurn || currentGameMode !== 'listenAndPickWord' || isMiniGameActive) return; const isCorrect = btn.textContent === currentCorrectWord; handleAnswer(isCorrect, btn); }); });
    soundChoiceBtns.forEach(btn => { btn.addEventListener('click', () => { if (questionAnsweredThisTurn || currentGameMode !== 'readAndPickSound' || isMiniGameActive) return; const wordToSpeak = btn.dataset.wordToSpeak; speak(wordToSpeak); if (selectedSoundButton && selectedSoundButton !== btn) { selectedSoundButton.classList.remove('sound-btn-selected'); } btn.classList.add('sound-btn-selected'); selectedSoundButton = btn; if(submitAnswerBtn) submitAnswerBtn.disabled = false; }); });
    submitAnswerBtn.addEventListener('click', () => { if (questionAnsweredThisTurn || currentGameMode !== 'readAndPickSound' || !selectedSoundButton || isMiniGameActive) return; const wordSpokenBySelectedButton = selectedSoundButton.dataset.wordToSpeak; const isCorrect = wordSpokenBySelectedButton === currentCorrectWord; handleAnswer(isCorrect, selectedSoundButton); });
    listenBtn.onclick = ()=>{ if (currentCorrectWord && !isMiniGameActive) { if (currentGameMode === 'listenAndPickWord') { speak(currentCorrectWord); } else { speak(currentCorrectWord); } } };
    timerDisp.addEventListener('click',()=>{ if (!isMiniGameActive) { timerSel.style.display = timerSel.style.display==='block'?'none':'block'; timerSel.value = timeLimit; } });
    timerSel.addEventListener('change',()=>{ timeLimit = +timerSel.value; timerDisp.textContent = timeLimit > 0 ? timeLimit+'s ‚è±Ô∏è' : 'Untimed ‚è±Ô∏è'; timerSel.style.display='none';});
    function showFloatingScore(message, targetButton, isError = false) { const floatEl = document.createElement('div'); floatEl.textContent = message; floatEl.classList.add('floating-effect'); floatEl.classList.add(isError ? 'floating-message' : 'floating-score'); if(isError) {floatEl.style.backgroundColor = 'var(--incorrect-bg)'; floatEl.style.color = '#333';} document.body.appendChild(floatEl); const btnRect = targetButton.getBoundingClientRect(); floatEl.style.left = `${btnRect.left + btnRect.width / 2 - floatEl.offsetWidth / 2}px`; floatEl.style.top = `${btnRect.top - floatEl.offsetHeight - 10}px`; gsap.to(floatEl, { y: -60, opacity: 0, duration: 1.8, ease: 'power1.out', onComplete: () => floatEl.remove() }); }
    function showFloatingMessage(text, bgColor = 'var(--brand)', textColor = 'white') { const msgEl = document.createElement('div'); msgEl.textContent = text; msgEl.classList.add('floating-effect', 'floating-message'); msgEl.style.backgroundColor = bgColor; msgEl.style.color = textColor; msgEl.style.left = '50%'; msgEl.style.top = '15%'; msgEl.style.transform = 'translateX(-50%)'; msgEl.style.padding = '0.8rem 1.5rem'; msgEl.style.fontSize = '1.5em'; document.body.appendChild(msgEl); gsap.fromTo(msgEl, { opacity: 0, y: -20, scale: 0.8 }, { opacity: 1, y: 0, scale: 1, duration: 0.5, ease: 'back.out(1.7)' } ); setTimeout(() => { gsap.to(msgEl, { opacity: 0, y: 20, scale: 0.8, duration: 0.5, ease: 'back.in(1.7)', onComplete: () => msgEl.remove() }); }, 2300); }

    // --- LEVEL MANAGEMENT (same as before) ---
    function initLevelManagement() { const storedLevels = localStorage.getItem('sightWordsSelectedLevels'); selectedLevels = storedLevels ? JSON.parse(storedLevels) : ['A']; Object.keys(allLevelWords).forEach(levelKey => { const levelItem = document.createElement('div'); levelItem.classList.add('level-item'); levelItem.dataset.level = levelKey; levelItem.textContent = `Level ${levelKey}`; const longPressHint = document.createElement('span'); longPressHint.classList.add('long-press-indicator'); longPressHint.textContent = '(hold to customize)'; levelItem.appendChild(longPressHint); if (selectedLevels.includes(levelKey)) { levelItem.classList.add('selected'); } levelItem.addEventListener('mousedown', (e) => handleLevelInteractionStart(e, levelKey)); levelItem.addEventListener('touchstart', (e) => handleLevelInteractionStart(e, levelKey), { passive: false }); levelItem.addEventListener('mouseup', handleLevelInteractionEnd); levelItem.addEventListener('mouseleave', handleLevelInteractionEnd); levelItem.addEventListener('touchend', handleLevelInteractionEnd); levelItem.addEventListener('touchcancel', handleLevelInteractionEnd); levelsDropdownMenu.appendChild(levelItem); }); levelsToggleBtn.addEventListener('click', (e) => { e.stopPropagation(); levelsDropdownMenu.classList.toggle('visible'); }); document.addEventListener('click', (event) => { if (!levelsToggleBtn.contains(event.target) && !levelsDropdownMenu.contains(event.target)) { levelsDropdownMenu.classList.remove('visible'); } }); modalSaveBtn.addEventListener('click', saveCustomWordSelection); modalCloseBtn.addEventListener('click', closeWordSelectionModal); modalSelectAllBtn.addEventListener('click', () => toggleAllModalWords(true)); modalDeselectAllBtn.addEventListener('click', () => toggleAllModalWords(false)); updateActiveQuizWords(); }
    function handleLevelInteractionStart(event, levelKey) { if(isMiniGameActive) return; event.preventDefault(); isLongPress = false; clearTimeout(longPressTimer); longPressTimer = setTimeout(() => { isLongPress = true; openWordSelectionModal(levelKey); levelsDropdownMenu.classList.remove('visible'); }, 500); }
    function handleLevelInteractionEnd(event) { clearTimeout(longPressTimer); if (!isLongPress) { const target = event.currentTarget; if (target && target.dataset.level && !isLongPress) { toggleLevelSelection(target.dataset.level, target); } } }
    function toggleLevelSelection(levelKey, levelItemElement) { const index = selectedLevels.indexOf(levelKey); if (index > -1) { selectedLevels.splice(index, 1); levelItemElement.classList.remove('selected'); } else { selectedLevels.push(levelKey); levelItemElement.classList.add('selected'); } localStorage.setItem('sightWordsSelectedLevels', JSON.stringify(selectedLevels)); updateActiveQuizWords(); }
    function updateActiveQuizWords() { words = []; selectedLevels.forEach(levelKey => { const customWordsJson = localStorage.getItem(`${levelKey}_customWords`); if (customWordsJson) { const customWords = JSON.parse(customWordsJson); if (customWords.length > 0) { words.push(...customWords); } else { words.push(...allLevelWords[levelKey]); } } else { words.push(...allLevelWords[levelKey]); } }); words = [...new Set(words)]; if (words.length === 0 && allLevelWords.A) { words.push(...allLevelWords.A); if(!selectedLevels.includes('A')) { selectedLevels.push('A'); const levelAItem = levelsDropdownMenu.querySelector(`.level-item[data-level="A"]`); if(levelAItem) levelAItem.classList.add('selected'); localStorage.setItem('sightWordsSelectedLevels', JSON.stringify(selectedLevels)); } showFloatingMessage("Using Level A words as no others were selected.", "var(--brand-dark)"); } clearTimeout(questionTimeoutId); resetQuestionState(); setTimeout(nextQ, 100); }
    function openWordSelectionModal(levelKey) { currentEditingLevelKey = levelKey; modalLevelTitle.textContent = `Customize Level ${levelKey} Words`; modalWordList.innerHTML = ''; const levelWords = allLevelWords[levelKey]; const customWordsJson = localStorage.getItem(`${levelKey}_customWords`); let customWords = []; if (customWordsJson) { customWords = JSON.parse(customWordsJson); } levelWords.forEach(word => { const itemDiv = document.createElement('div'); itemDiv.classList.add('modal-word-item'); const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.id = `modal-word-${word.replace(/\s+/g, '-')}`; checkbox.value = word; checkbox.checked = customWords.includes(word); const label = document.createElement('label'); label.htmlFor = checkbox.id; label.textContent = word; itemDiv.appendChild(checkbox); itemDiv.appendChild(label); itemDiv.addEventListener('click', (e) => { if (e.target !== checkbox) checkbox.checked = !checkbox.checked; }); modalWordList.appendChild(itemDiv); }); wordSelectionModal.classList.add('visible'); }
    function closeWordSelectionModal() { wordSelectionModal.classList.remove('visible'); currentEditingLevelKey = null; }
    function saveCustomWordSelection() { if (!currentEditingLevelKey) return; const selectedCustomWords = []; modalWordList.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => { selectedCustomWords.push(cb.value); }); localStorage.setItem(`${currentEditingLevelKey}_customWords`, JSON.stringify(selectedCustomWords)); closeWordSelectionModal(); updateActiveQuizWords(); }
    function toggleAllModalWords(select) { modalWordList.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = select; }); }

  </script>
</body>
</html>
